---
title: コード×AIーソフトウェア開発者のための生成AI実践入門
tags:
  - AI
private: true
updated_at: '2025-02-19T22:13:10+09:00'
id: 79c9ac9b0b15102e345e
organization_url_name: null
slide: false
ignorePublish: false
---
https://gihyo.jp/book/2024/978-4-297-14484-5

# 第1章 生成AIがエンジニアリングの常識を変える

- プロンプトのテクニックはあまり重要じゃない
  - 期待されているほどの大きな効果は生まない
- AIの出力精度を高める具体的なテクニック
  - Few-shot
  - Chain-of-Thought
  - 抽象的なプロンプトは良くない（例：～～するコード書いて）

### トークンの感覚的理解

- 英単語は1トークン、日本語は1文字で1トークン（ただし例外あり）
  - 「こんにちは」は1トークンだったりする
- トークン数は1000~2000くらいを上限とする。じゃないと出力精度が下がる

### 開発支援AIツールは使い分ける

- 自動補完型：Github Copilot
- 対話型：ChatGPT
- エージェント型：Github Copilot Workspace

# 第2章 プロンプトで生成AIを操る

- 再利用するか使い捨てのプロンプトか見極める
    - エンジニア業務ではほとんどが使い捨て
    - 自分が書くプロンプトは最小限で欲しい情報を引き出せるようになる
        - 使い捨てのプロンプトなら短いほどいい
- 定期的にメンテナンスしないと、再利用できるプロンプトは難しい
    - AIも日々進化するので、無理する必要ない

### プロンプトの構成要素

- 意図（Intent）、コンテキスト、コンテンツを意識する
    - 意図：基本的な命令
    - コンテキスト：背景や既存実装、プロジェクトの状態なと
    - コンテンツ：取り出したい情報、関数名や引数、戻り値など
- 制約は大事
    - 例）コメントは含めないでください

### 約束を破るAIへの対処

- 条件を具体化
- ** で囲んで強調
- `**絶対**`や`**間違いなく**`を使う
- 同じ言い回しや、別の言い方で二回言う
    - 例）絶対〇〇してください。絶対に〇〇してください。

### 専門性を引き出すロールプレイ

- 最小限の設定でも十分
    - 大企業で働く～など意味が不明確なロールは不要
    - 例）あなたは Unity のエキスパートです。

以下のように、自動的に回答者の役割を与えることも可能。

```
Q: vim のコマンドで、HTMLタグを全部消す方法は
A: 
```

### Few-shot プロンプティング

- 例を与えて、それを参考に生成してもらう方法
    - 提供するサンプルの質が大事

### Zero-shot プロンプティング


- 例を与えずに直接質問やタスクを与える方法
    - 有名な言語やフレームワークだと精度が高い

### 効率重視の言語戦略

- 日本語より英語のほうが精度が高い
    - 将来的に技術進歩で差は縮まる
        - もし精度を重要視するなら英語でプロンプト書いたほうがいい
            - 同じ内容ならトークンも英語のほうが小さく済む
        - 英語を読むのに体力使うなら日本語のままでOK

### 文脈分離のための区切り文字

- HTMLタグや --- や Markdown 記法などで区切ることで文脈を明示的に示すことに効果的
    - 精度に差はあまりないので、使いやすいものでOK

# 第3章 プロンプトの実例と分析

- 他社のプロンプトを参考にすることは大事

### 大事な構成要素

- ロールプレイと基本指示
    - 例）Unity開発者として行動してください。説明を元に～～を作成してください
- 要件を満たすための指示
    - 指示を無視したり、出力を省略したりすることを防ぐ
    - 例）美しく使いやすいようにしてください。すべてのユースケースをカバーしてください。完全なコードを書いてください。
- フォーマット、出力形式の指示
    - Few-shot プロンプティングの例文のように
    - なにを return してほしいか明確に
- 条件の明確化
    - バージョン、フレームワーク、ライブラリなど

### とはいえ、こんなに書くのは大変

- ユーザープロンプトは雑で、必要最低限でいい
- 例をすべて真似る必要はない
    - AIを使って何を実現したいのか明確に、最小限の文章で伝える

# 第4章 AIツールに合わせたプロンプト戦略

### 自動補完型AIツール

- 関数を途中まで入力した時点でプロンプトが自動生成される
    - レスポンスが早い
- コメントで5~10行とか長いプロンプトは書くべきじゃない
- ウィンドウを切り替える必要がないので、コンテキストスイッチがない

### 対話型AIツール

- いろんなファイル拡張子をサポート
    - 要約を生成したりできる
- 外部情報へのアクセス
    - インターネット検索結果から回答
    - 最新の技術動向やトレンドの質問にも対応可能
- 履歴の積み上げと再利用
    - トークン数による上限がある点は注意
- 「改善点をリストアップしたうえで、改善例を提案してください」
    - AIの提案を鵜呑みにしないことが大事
    - AIに全てを委ねたり、あまり確認せずAIに連投するのは良くない
- ファイルを丸ほどアップロードするのは必ずしも有効じゃない
    - 結局ファイルを解析するのにトークン数が増えるので効率的じゃない

### エージェント型AIツール

割愛

# 第5章 AIと協働するためのコーディングテクニック

- 自分がレビュー可能な情報リョウを把握することが重要
- AI が提案するコードの品質を向上させるなら、自分のコードの質を高めることは必須
- AIは検索と生成の2つの処理
  - 生成する前に検索にヒットする必要あり
- AIにより、冗長なコメントを残す必要がなくなった
  - コードを解説してくれるので
  - AIが解説できない部分に焦点を当てる
    - 業務ドメイン固有の情報など
 
# 第6章　AIの力を引き出すための開発アプローチ

- 自分がレビューしやすいコードを書く
- ブロック節を使ってネストを深くしない
- AIに触れさせないために計算ロジックを独立させる

```
以下の関数に対して、構成、役割変更、順番の再構成、単純化の観点で改善点を挙げてください
```

- AIは既存コードを真似ることは得意だが、既存コードを改変する意思決定は苦手
  - OCPの原則に倣って設計しておくと良い

### 体系的なリファクタリング手法の適用

- 何を改善したいのか明確にすることが重要
  - 適切な指標とリファレンスを参照することが重要

```
以下のコードに対して Thoughtworks 社の "Refactoring Catalog" に基づいたリファクタリングを行います。指摘とその解説を10個以上生成してください。
```

```
以下のコードに対して以下の Refactoring Catalog の観点で指摘してください。
- Change Function Declaration
- Change Reference to Value
```

TODO: あとでリンク貼る

### 小規模 OSS の再実装

- OSSに依存しすぎると思わぬ問題に直面することがある
- AIで簡単に生成できるような小規模なコードはOSSに頼らずにAIに任せる

### 6.2 AIを活用したコード品質向上

- 実装をしたあとにテストコードを書いてもらっても、実装に依存したテストコードになるので良くない

1. 発散：テストケースのパターンを生成してもらう
2. 整理：パターンの整理をAIに依頼し、人間がレビューする
3. 収斂：網羅されたテストケースを絞り込む
4. 選択：テストケースを選別する
5. 実装：AIにテストコードを実装させる

- AIが自動で出力してくれるからといって、無駄なテストは残さないように注意

### 6.3 コードリーディングにおけるAIの活用

- AIにコードの流れや構造を可視化してもらう
  - Mermaid や PlantUML でフロー図、アクティビティ図、シーケンス図、クラス図、状態遷移図を作ってもらう

```おすすめ指示1
解説はステップバイステップで、詳細に行ってください
```

```おすすめ指示2
各関数の役割と、関数間の関係を説明してください
```

```おすすめ指示3
コードの構造（インデントなど）を保持しつつ、簡潔に解説してください。
```

### 6.4 コードレビューにおけるAIの活用

- コーディングインタビューの本を参考にする
  - 「世界で闘うプログラミング力を鍛える本 〜コーディング面接 189 問とその解法〜」
- アルゴリズムの Big−O 記法による計算量の評価
- スタックやキューなどのデータ構造の適切な使用法
- メモリ効率や実行効率の改善方法

避けるべき質問
```
このプログラムのパフォーマンスを向上させるためにはどのような方法がありますか?
```

入力すべき質問
```
このコードの時間計算量をO(n)以下にするためにはどうすればよいですか？
```

```
次のコードの時間計算量をBig-O記法で表現し、O(1)に改善する方法を提案してください。
```

- BUDフレームワークを用いたコード最適化
  - ボトルネック
  - アンネセサリー：不必要で冗長な処理
  - デュプリケイト：同じ処理が複数書いてる

```
このプログラムに関して、BUD の観点から問題点を特定してください。 また、それぞれの問題点に対する具体的な改善案を提案してください。
```

- BUDフレームワークで問題を特定したら、適切なアルゴリズムや問題解決手法を使うべき
  - より効率的なデータ構造
  - 不必要な計算を削除
  - 問題を小さなサブ問題に分割し、再帰的に解決
  - 重複する部分問題の結果を保存し、再利用

```
どのような問題解決手法やアルゴリズム設計技法を適用することができますか？
```

### 6.4.3 データ構造の妥当性

- 適切なデータ構造を選択することでプログラムの効率性、保守性を改善できる

```
このプログラムに関して、どのようなデータ構造を使用することができますか？
```

```
該当のコードに関して、現在のデータ構造を改善したいです。どのように変更すればよいですか？
```

### 6.4.4 SOLID原則に基づくコード品質の向上

```
SOLID原則の観点から、このプログラムにはどのような問題がありますか？ どのように設計を変更すれば、このプログラムの拡張性を向上させることができますか？
```

### 6.4.5 Chain-of-Thoughtプロンプティング

- 「ステップバイステップで考えよう」とスクリプトに含めると良い

#### 実行効率の向上

```
以下のプログラムの非効率な部分はどこですか？ ステップバイステップで解説してください。
```

#### 複雑なバグの特定

```
以下のプログラムのバグを特定して修正してください。 その方法をステップバイステップで解説してください。
```

#### 学習の手助け

```
以下のプログラムをステップバイステップで説明してください。
```

# 第7章 生成AIの力を組織で最大限に引き出す


### AI が読みやすいコードの特徴

- コードが記述的かつ文脈が明確で、初見でも理解しやすいこと
- 比較的メジャーなバージョンや技術スタックで書かれていること
- 継続的にメンテナンスされ、常に使用可能な状態であること

### インナーソースとは

- 企業内でオープンソースのような文化を醸成し、透明度の高い協働の文化を作る
