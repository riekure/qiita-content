---
title: コード×AIーソフトウェア開発者のための生成AI実践入門
tags:
  - AI
private: true
updated_at: '2025-02-19T22:13:10+09:00'
id: 79c9ac9b0b15102e345e
organization_url_name: null
slide: false
ignorePublish: false
---
https://gihyo.jp/book/2024/978-4-297-14484-5

# 第1章 生成AIがエンジニアリングの常識を変える

- プロンプトのテクニックはあまり重要じゃない
  - 期待されているほどの大きな効果は生まない
- AIの出力精度を高める具体的なテクニック
  - Few-shot
  - Chain-of-Thought
  - 抽象的なプロンプトは良くない（例：～～するコード書いて）

### トークンの感覚的理解

- 英単語は1トークン、日本語は1文字で1トークン（ただし例外あり）
  - 「こんにちは」は1トークンだったりする
- トークン数は1000~2000くらいを上限とする。じゃないと出力精度が下がる

### 開発支援AIツールは使い分ける

- 自動補完型：Github Copilot
- 対話型：ChatGPT
- エージェント型：Github Copilot Workspace

# 第2章 プロンプトで生成AIを操る

- 再利用するか使い捨てのプロンプトか見極める
    - エンジニア業務ではほとんどが使い捨て
    - 自分が書くプロンプトは最小限で欲しい情報を引き出せるようになる
        - 使い捨てのプロンプトなら短いほどいい
- 定期的にメンテナンスしないと、再利用できるプロンプトは難しい
    - AIも日々進化するので、無理する必要ない

### プロンプトの構成要素

- 意図（Intent）、コンテキスト、コンテンツを意識する
    - 意図：基本的な命令
    - コンテキスト：背景や既存実装、プロジェクトの状態なと
    - コンテンツ：取り出したい情報、関数名や引数、戻り値など
- 制約は大事
    - 例）コメントは含めないでください

### 約束を破るAIへの対処

- 条件を具体化
- ** で囲んで強調
- `**絶対**`や`**間違いなく**`を使う
- 同じ言い回しや、別の言い方で二回言う
    - 例）絶対〇〇してください。絶対に〇〇してください。

### 専門性を引き出すロールプレイ

- 最小限の設定でも十分
    - 大企業で働く～など意味が不明確なロールは不要
    - 例）あなたは Unity のエキスパートです。

以下のように、自動的に回答者の役割を与えることも可能。

```
Q: vim のコマンドで、HTMLタグを全部消す方法は
A: 
```

### Few-shot プロンプティング

- 例を与えて、それを参考に生成してもらう方法
    - 提供するサンプルの質が大事

### Zero-shot プロンプティング


- 例を与えずに直接質問やタスクを与える方法
    - 有名な言語やフレームワークだと精度が高い

### 効率重視の言語戦略

- 日本語より英語のほうが精度が高い
    - 将来的に技術進歩で差は縮まる
        - もし精度を重要視するなら英語でプロンプト書いたほうがいい
            - 同じ内容ならトークンも英語のほうが小さく済む
        - 英語を読むのに体力使うなら日本語のままでOK

### 文脈分離のための区切り文字

- HTMLタグや --- や Markdown 記法などで区切ることで文脈を明示的に示すことに効果的
    - 精度に差はあまりないので、使いやすいものでOK

# 第3章 プロンプトの実例と分析

- 他社のプロンプトを参考にすることは大事

### 大事な構成要素

- ロールプレイと基本指示
    - 例）Unity開発者として行動してください。説明を元に～～を作成してください
- 要件を満たすための指示
    - 指示を無視したり、出力を省略したりすることを防ぐ
    - 例）美しく使いやすいようにしてください。すべてのユースケースをカバーしてください。完全なコードを書いてください。
- フォーマット、出力形式の指示
    - Few-shot プロンプティングの例文のように
    - なにを return してほしいか明確に
- 条件の明確化
    - バージョン、フレームワーク、ライブラリなど

### とはいえ、こんなに書くのは大変

- ユーザープロンプトは雑で、必要最低限でいい
- 例をすべて真似る必要はない
    - AIを使って何を実現したいのか明確に、最小限の文章で伝える

# 第4章 AIツールに合わせたプロンプト戦略

### 自動補完型AIツール

- 関数を途中まで入力した時点でプロンプトが自動生成される
    - レスポンスが早い
- コメントで5~10行とか長いプロンプトは書くべきじゃない
- ウィンドウを切り替える必要がないので、コンテキストスイッチがない

### 対話型AIツール

- いろんなファイル拡張子をサポート
    - 要約を生成したりできる
- 外部情報へのアクセス
    - インターネット検索結果から回答
    - 最新の技術動向やトレンドの質問にも対応可能
- 履歴の積み上げと再利用
    - トークン数による上限がある点は注意
- 「改善点をリストアップしたうえで、改善例を提案してください」
    - AIの提案を鵜呑みにしないことが大事
    - AIに全てを委ねたり、あまり確認せずAIに連投するのは良くない
- ファイルを丸ほどアップロードするのは必ずしも有効じゃない
    - 結局ファイルを解析するのにトークン数が増えるので効率的じゃない

### エージェント型AIツール

割愛

# 第5章 AIと協働するためのコーディングテクニック

- 自分がレビュー可能な情報リョウを把握することが重要
- AI が提案するコードの品質を向上させるなら、自分のコードの質を高めることは必須
- AIは検索と生成の2つの処理
  - 生成する前に検索にヒットする必要あり
- AIにより、冗長なコメントを残す必要がなくなった
  - コードを解説してくれるので
  - AIが解説できない部分に焦点を当てる
    - 業務ドメイン固有の情報など
 
# 第6章　AIの力を引き出すための開発アプローチ

- 自分がレビューしやすいコードを書く
- ブロック節を使ってネストを深くしない
- AIに触れさせないために計算ロジックを独立させる

```
以下の関数に対して、構成、役割変更、順番の再構成、単純化の観点で改善点を挙げてください
```

- AIは既存コードを真似ることは得意だが、既存コードを改変する意思決定は苦手
  - OCPの原則に倣って設計しておくと良い

### 体系的なリファクタリング手法の適用

- 何を改善したいのか明確にすることが重要
  - 適切な指標とリファレンスを参照することが重要

```
以下のコードに対して Thoughtworks 社の "Refactoring Catalog" に基づいたリファクタリングを行います。指摘とその解説を10個以上生成してください。
```

```
以下のコードに対して以下の Refactoring Catalog の観点で指摘してください。
- Change Function Declaration
- Change Reference to Value
```

TODO: あとでリンク貼る

### 小規模 OSS の再実装

- OSSに依存しすぎると思わぬ問題に直面することがある
- AIで簡単に生成できるような小規模なコードはOSSに頼らずにAIに任せる

### 6.2 AIを活用したコード品質向上

- 実装をしたあとにテストコードを書いてもらっても、実装に依存したテストコードになるので良くない

1. 発散：テストケースのパターンを生成してもらう
2. 整理：パターンの整理をAIに依頼し、人間がレビューする
3. 収斂：網羅されたテストケースを絞り込む
4. 選択：テストケースを選別する
5. 実装：AIにテストコードを実装させる

- AIが自動で出力してくれるからといって、無駄なテストは残さないように注意

### 6.3 コードリーディングにおけるAIの活用

- AIにコードの流れや構造を可視化してもらう
  - Mermaid や PlantUML でフロー図、アクティビティ図、シーケンス図、クラス図、状態遷移図を作ってもらう

```おすすめ指示1
解説はステップバイステップで、詳細に行ってください
```

```おすすめ指示2
各関数の役割と、関数間の関係を説明してください
```

```おすすめ指示3
コードの構造（インデントなど）を保持しつつ、簡潔に解説してください。
```

### 6.4 コードレビューにおけるAIの活用

- コーディングインタビューの本を参考にする
  - 「世界で闘うプログラミング力を鍛える本 〜コーディング面接 189 問とその解法〜」
- アルゴリズムの Big−O 記法による計算量の評価
- スタックやキューなどのデータ構造の適切な使用法
- メモリ効率や実行効率の改善方法

避けるべき質問
```
このプログラムのパフォーマンスを向上させるためにはどのような方法がありますか?
```

入力すべき質問
```
このコードの時間計算量をO(n)以下にするためにはどうすればよいですか？
```

```
次のコードの時間計算量をBig-O記法で表現し、O(1)に改善する方法を提案してください。
```

- BUDフレームワークを用いたコード最適化
  - ボトルネック
  - アンネセサリー：不必要で冗長な処理
  - デュプリケイト：同じ処理が複数書いてる

```
このプログラムに関して、BUD の観点から問題点を特定してください。 また、それぞれの問題点に対する具体的な改善案を提案してください。
```

- BUDフレームワークで問題を特定したら、適切なアルゴリズムや問題解決手法を使うべき
  - より効率的なデータ構造
  - 不必要な計算を削除
  - 問題を小さなサブ問題に分割し、再帰的に解決
  - 重複する部分問題の結果を保存し、再利用

```
どのような問題解決手法やアルゴリズム設計技法を適用することができますか？
```

### 6.4.3 データ構造の妥当性

- 適切なデータ構造を選択することでプログラムの効率性、保守性を改善できる

```
このプログラムに関して、どのようなデータ構造を使用することができますか？
```

```
該当のコードに関して、現在のデータ構造を改善したいです。どのように変更すればよいですか？
```

### 6.4.4 SOLID原則に基づくコード品質の向上

```
SOLID原則の観点から、このプログラムにはどのような問題がありますか？ どのように設計を変更すれば、このプログラムの拡張性を向上させることができますか？
```

### 6.4.5 Chain-of-Thoughtプロンプティング

- 「ステップバイステップで考えよう」とスクリプトに含めると良い

#### 実行効率の向上

```
以下のプログラムの非効率な部分はどこですか？ ステップバイステップで解説してください。
```

#### 複雑なバグの特定

```
以下のプログラムのバグを特定して修正してください。 その方法をステップバイステップで解説してください。
```

#### 学習の手助け

```
以下のプログラムをステップバイステップで説明してください。
```

# 第7章 生成AIの力を組織で最大限に引き出す


### AI が読みやすいコードの特徴

- コードが記述的かつ文脈が明確で、初見でも理解しやすいこと
- 比較的メジャーなバージョンや技術スタックで書かれていること
- 継続的にメンテナンスされ、常に使用可能な状態であること

### インナーソースとは

- 企業内でオープンソースのような文化を醸成し、透明度の高い協働の文化を作る

- メンテナンスされていないソースコードは、開発者やAIにとって大きな問題
- それを元に生成されたコードにも同じ問題が発生する可能性がある→品質の低下

##  7.2 AI時代のソフトウェア開発手法をチームで体得する

-AIの特性と限界への理解
  - 適切な命令、レビュー、修正が不可欠
- 組織としての方針の明確化
  - メンテやレビュー方法、管理方法の明確
- AI から得た知見の共有
  - 有益だったプロンプト、AI から学んだコードやデバッグ方法などを共有

## 7.3 AIペアプログラミング

- AI が提示したコードをそのままプルリクに出してしまう
  - 成長機会を失ってしまう

```
■ 二人で開発支援AIツールを使いながら、通常のプログラミングを行います。 
■ AIへの指示のしかたや、開発の質を上げるコツを互いに共有します。 
■ AIが出力したコードについて、お互いに解説したり質問したりしながら改善点を探ります。
```

### 7.2.3 プロンプトのユースケースの共有

- 社内でプロンプトを共有しても効果は薄い
  - タスクのほとんどが使い捨て
  - 自分が求める結果が確実に得られるわけではない
- プロンプトは結局 AI のアウトプットを見て、自分の業務に適応シていく必要あり
- 「完璧なプロンプトを共有しなければならない」という意識が、共有のハードルを上げてしまう恐れ
- 日常的に定期的に共有することが大事

### 7.2.4 AI 活用の推進チャンピオン育成

- How[「方法」に注目しがちだけとWhat「内容」の共有も大事

## 7.3 AI とドキュメント

- AI に情報を渡すときは Markdown と Mermaid がおすすめ
  - どちらもスタンダードで AI が理解しやすい
  - 図もテキストで表現できる
  - 画像を渡すにしても情報量に注意
    - 入力はシンプルに、出力も確認しやすいようにするのがポイント
   
### 7.3.2 実装からの仕様書生成

- 実装から仕様書作成はAIの得意分野
  - フォーマットを指定して、より詳細なドキュメントを生成可能
 
```
- Markdown Table として出力してください。
- テーブル内の改行は `<br/>` を使ってください。
- 各仕様書の項目は以下です。それぞれ別カラムで出力してください。
  - メソッド名
  - 概要
  - パラメータ
  - 戻り値
  - 内部のSQLクエリ
- メソッド名は太字にしてください。
```

## 7.4 AI 時代に適合したチーム技術スタックの最適化

- チームの技術スタックを AI 時代に適応させる
  - 技術スタックを標準化させると結果的に開発効率を向上
- zero-shot プロンプティングので取得できる範囲の把握
- 組織内に蓄積されたナレッジの活用も大事
- 情報はMarkdownにまとめておくと良い
- 生成 AI が出力するコードが必ず安全だとは言えない
  - 必要に応じて改善することが必要
 
## 7.5 生成 AI 導入効果の評価

- AI のコスパはいいが効果測定が難しい
  - 「生産性」の話になりがちだが、もっと多面的な視点でみる
    - コード量で見ようとすると、めちゃくちゃ改行すればステップ数は稼げる
 
### 7.5.1 Developer Experience（開発者体験）

- 開発者体験 = (開発者生産性 + 開発者インパクト + 開発者満足度)
- デリバリーに目が行きがちだけどそれ以外も大事
- 開発者生産性…効率性とスピードを表し、開発者がタスクを効率的にどれだけ速く完了できるか
- 開発者インパクト…どれだけ迅速にアイディアを実際の製品やサービスに変えられたか
- 開発者満足度…開発者が自分の仕事にどれだけ満足しているか、ワークフローがどれだけスムーズか、使用しているツールがどれだけ効果的か

### 7.5.2 Four Keysによる開発プロセス評価

| メトリクス               | 内容                                                              |
| :----------------------- | :---------------------------------------------------------------- |
| デプロイ頻度             | 本番環境へのリリースが成功する頻度を測定します。                 |
| 変更のリードタイム         | コードのコミットから本番環境へのデプロイまでの時間を追跡します。 |
| 変更失敗率               | 本番環境でのデプロイの失敗率を評価します。                       |
| 平均復旧時間(MTTR)        | 本番環境での障害からの平均復旧時間を測定します。                 |


AI ツールの導入効果

- 「AIツールにより作業時間が何%削減されたか」や「コード品質が向上したと感じるか」といった具体的な質問を設定することで、より精度の高い評価が可能
- isuue が作成されてから解決までのリードタイム
