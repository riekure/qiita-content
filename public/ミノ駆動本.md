# 第2章 設計の初歩

- 省略せずに意図が伝わる名前付けをする
- 変数は使い回さない
- 目的ごとにメソッド化
- 関連するデータとロジックはクラスにまとめる = カプセル化

# 第3章 カプセル化の基礎 - ひとつにまとめる

- クラスの構成要素
  - インスタンス変数
  - 完全性を保証するようにインスタンス変数を操作するメソッド
- カプセル化
  - データとそのデータを操作するロジックをひとつにまとめる
- 関心の分離
- 多態性による機能の取り換え

## 3.1 クラス単体で正常に動作するように設計する

- データ単体のクラスだと正常動作は無理
  - クラス単体で動くように設計する
- ドメインモデルの完全性
  - データやロジックに欠損や不整合がなく、正確な状態を維持できること
- 貧血ドメインモデル
  - わざわざ他のクラスに初期化してもらったり、データをチェックしてもらったり、ほかのクラスのメソッドを呼び出さないと機能しないようなデータクラス
- 値の渡し間違いは型で防止
- 整数は int , 文字列は string にしがち
  - Money 型みたいな独自の型に使う
- システムの仕様に必要なメソッドのみを定義
- メソッド引数もローカル変数も final を付与して不変にする

## 3.4 プログラム構造の問題解決に役立つ設計パターン

- 完全コンストラクタ
- 値オブジェクト
- 「値オブジェクト + 完全コンストラクタ」は、カプセル化の最も基本形を体現している構造のひとつ

# 第4章　不変の活用 安定動作を保障する

- ローカル変数も引数も不変（再代入不可）にする
  - 同じインスタンスの使い回しをやめる
- 大量データの高速処理や画像処理、リソース制約の厳しい組込みソフトウェアなどで可変が必要なことがあります
- パフォーマンス以外で可変にして良いのは、スコープが局所的なケースです。ループカウンタなど、ループ処理のスコープでしか使われないことが確実なローカル変数ならば、可変にしてよいと考えます。

### 4.2.3 副作用のデメリット

- 副作用とは、関数が引数を受け取り、戻り値を返す以外に外部の状態を変更すること
  - インスタンス変数の変更
  - グローバル変数の変更
  - 参照型引数の変更
  - ファイルの読み書きなどの I/O 操作

- コード外とのやりとりには注意が必要
- コードの外の状態に依存すると、見通して見る

# 第5章 バラバラなデータとロジックをカプセル化する実践技法

- プリミティブ型を乱用しない
  - データのありかと制御ロジックの場所がバラバラになりがち
- static メソッドを乱用しない
  - カプセル化できない（データとデータ操作するロジックが乖離）
  - インスタンス変数、メソッドを使う
- インスタンスメソッドのふりしたstaticメソッドもある
  - 見分ける方法はstaticをつけてみること
- Common や Utils は  static と同じ問題抱えがち
  - 共通処理用のメソッドはstaticメソッドとして実装されがち
- オブジェクト指向設計の基本に基づいて設計しよう 
- **横断的関心事**…様々なユースケースで広く横断する処理は static でも問題ない
  - ログ出力（Logger）
  - エラー検出
  - デバッグ
  - 例外処理
  - キャッシュ
  - 同期処理
  - 分散処理
- 結果を返すために引数を使わない
  - C#のoutキーワードは次に示すTryParseメソッドのように、汎用的な変換用途などに限定する
  - カプセル化に問題が生じる場合は使用しない
- 引数が多すぎるのも良くない
  - 引数が多い場合は、意味がある単位ごとにクラス化する
- ```.``` で数珠つなぎで階層構造でアクセスするのはNG
  - 関連ロジックがバラバラになる良くない書き方
  - 例：```party.members.get(memberId).equipments.armor = newArmor;```
  - **デメテルの法則に違反**
    - 「知らない人に話しかけるな」

# 第6章　関心の分離という考え方 —分けて整理する—

- **関心の分離**
  - それぞれの関心をモジュールに分けて、他の関心の分離する考え方
  - カプセル化と密接な関係
- うまく別クラスに分離するためには、インスタンス変数とメソッドがどこと関連づいているか把握することが大事
  - 関係していそうなロジックを1つまとめたけど、徐々に肥大化しがち
    - **目的ごとに分離し、カプセル化する、という設計が関心を上手く分離する上で重要**
- **インターフェースと実装の分離**
  - 実装パートのインスタンス変数やロジックをモジュールの外に見せない
  - モジュール間はインターフェースを呼び出すだけ
    - メリット①：注意の負荷軽減 = ロジックが隠されたので注意を払う場所が減る
    - メリット②：仕様変更に強くなる = ロジック変更しやすい

# 第7章　関心が混ざったコードを分けて整理する実践技法

- ロジックを流用すると異なる関心が混在しがち
- **単一責任の原則**：クラスが担う責任は1つに限定すべき
  - 同じようなロジックが複数あるからといって、責任を考えずに無理やりひとまとめにするのはNG
  - 同じようなロジックでも、目的が違うロジックは共通化しない
  - **共通化していいのは、目的が同じときだけ**
- **継承は推奨しない**
  - サブクラスはスーパークラスに依存（スーパークラス依存）
  - サブクラスはスーパークラスを常に機にする必要あり
- **継承ではなく委譲**
  - スーパークラスではなく private なインスタンス変数として扱う = **コンポジション構造**
  - 下手に継承を使わずに丁寧にカプセル化、関心を分離することが重要
- **なんでも public にしない**
  - アクセス修飾子は適切に制御しないと、メンテナンスが困難になっちゃう
- **private だらけのクラスも注意**
  - private が多いクラスは、さまざまな関心を持っている可能性が高い
    - 異なる関心のロジックを private メソッドで実装している
- **表示と表示以外をそれぞれ別のクラスに分離する**
  - 新デザインに差し替えるとき大変になる
- **巨大データクラス**
  - 何も考えずに実装すると、さまざまなデータの置き場所になって巨大なデータクラスになる
  - グローバル変数と同様の弊害が起きがち
- **神クラス**
  - 1クラスに何千何万行も記述されて、あらゆるロジックが絡み合うようなクラス
- **巨大データクラスも神クラスも、カプセル化と関心の分離で設計することで対処**

# 第8章　条件分岐 —迷宮化した分岐処理を解きほぐす技法—

- `interface` を使って機能を取り替えるテクニックが重要
- 早期 `return` （ブロック節）で、ネストが深くならないようにする
  - `else` も `else if` も早期 `return` で読みやすくなる
- `switch` 文も良くない
  - 同じ条件の `switch` 文は増殖しがち
  - `case` 文の追加漏れが起こりうる
  - 単一責任の原則にならって、条件分岐を1箇所にまとめる
  - `interface` を使うことで構造をシンプルにできる
- **ストラテジーパターンも有効**
  - `switch` と違って実装漏れに気づきやすい
     - 目的別に異なる型の値オブジェクトを用意すると値の受け渡しミスを防げる
- 条件分岐のネストには**ポリシーパターン**が有効
  - 判定文を部品化して、部品化した条件を組み合わせることができるようにする仕組み
- `interface` の使い方を正しく理解しないとメンテナンスが難しいコードになる
  - **型判定による分岐(instanceof)は絶対禁止**
- フラグ引数は可読性低下につながる
  - 条件分岐ごとに関数化して分離したほうがいい
- **分岐を書きそうになったら、まずinterface設計！分岐ではなく機能の取り換え！**

# 第9章　コレクション —ネストを解消する構造化技法—

- 自前でコレクション処理を実装するのは止めよう（車輪の再開発）
  - コレクション処理はあちこちに実装されがち
- **ファーストクラスコレクション**
  - コレクションに関連する処理をカプセル化する設計手法
  - 以下2つの要素で構成
    - コレクション型インスタンス変数
    - 完全性を保証するようにコレクション型インスタンス変数を操作するメソッド
- インスタンス変数を変更できる形で外部に渡さない
  - Java でいう `unmodifiableList` を使う

# 第10章 設計の健全性をそこなうさまざまな悪魔たち

- デッドコード
  - 見つけたらすぐ削除
- YAGNI原則
  - You aren’t going to need it.
  - 先回りで実装しても、ほとんど使われないことが多い
  - いま必要な機能だけ作って構造をシンプルに
- マジックナンバー
  - あとから読み直したときに意図を理解できなくなる
  - 数値の意図を理解できるように定数を定義
- 文字列型終着
  - なんでもかんでも string に突っ込む
  - 適切な型を使う
- グローバル変数
  - 巨大なデータクラスも同じ
  - 可能な限りグローバル変数として定義せず、カプセル化し、アクセス可能なパッケージやクラスを限定する
- `null` 問題
  - `null` が入る前提でロジックを組むと `null` チェックを都度入れる必要が出てくる
    - `null` を返さない、渡さない、代入しない
    - `null` 安全 ＝ `null` 非許容型があれば積極的に使う
- 例外の握りつぶし
  - 例外をキャッチしたときには、通知や記録、場合によってはリカバリ処理を実行
  - 絶対に例外を握りつぶさない
- リフレクションによるクラス構造および値の変更
  - final で不変にした変数や private なインスタンス変数を変更できたりする
- クラス名やメソッド名のハードコード
  - IDE の静的解析や一括置換などが機能しなくなる
- 技術駆動パッケージング
  - 例…Model, View, Presenter でフォルダ、パッケージを分けること
    - 本来関係し合うファイルがバラバラになる
  - **在庫、注文、支払いなど同じ分類同士で分けると良い**
- ソフトウェア開発に銀の弾丸はない
  - 本書の技法を何でもかんでも使うのは良くない
    - あくまで変更が入りやすい箇所に適用するのが効果的
  - 設計はベストではなく、常にベターを目指す

# 第11章 名前設計 —あるべき構造を見破る名前—

- 目的名前駆動設計
  - 名前から目的や意図が読み取れることを重視
- NG:商品
  - 出品、予約、発送など商品の様々なユースケースを取り扱うことになって巨大複雑化する
  - 予約品、在庫品、注文品、発注品など関心事で分離、適切な名付けをする
    - 影響範囲が小さくなり、開発生産性が向上する
- **名前の設計のポイント**
  - 特定の目的の達成に特化した、意味の狭い名前をクラスに付与
  - 具体的な目的が分かる名前にする
  - どんな業務目的があるか分析する
  - 声に出して話してみる
  - 利用規約を読んでみる
    - サービスの取り扱いやルールが極めて厳密な言い回しで書かれており、目的に特化した名前の参考になる
    - 業務ルールとクラスが一致していると仕様変更時に対応しやすい
  - 違う名前に置き換えられないか検討する
    - 長期運用や仕様変更で今の名前が適切じゃなくなってくることがある
  - 関心が分離されているか点検する


