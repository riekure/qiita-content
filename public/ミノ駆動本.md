# 第2章 設計の初歩

- 省略せずに意図が伝わる名前付けをする
- 変数は使い回さない
- 目的ごとにメソッド化
- 関連するデータとロジックはクラスにまとめる = カプセル化

# 第3章 カプセル化の基礎 - ひとつにまとめる

- カプセル化
  - データとそのデータを操作するロジックをひとつにまとめる
- 関心の分離
- 多態性による機能の取り換え

## 3.1 クラス単体で正常に動作するように設計する

- データ単体のクラスだと正常動作は無理
  - クラス単体で動くように設計する
- ドメインモデルの完全性
  - データやロジックに欠損や不整合がなく、正確な状態を維持できること
- 貧血ドメインモデル
  - わざわざ他のクラスに初期化してもらったり、データをチェックしてもらったり、ほかのクラスのメソッドを呼び出さないと機能しないようなデータクラス
- 値の渡し間違いは型で防止
- 整数は int , 文字列は string にしがち
  - Money 型みたいな独自の型に使う
- システムの仕様に必要なメソッドのみを定義
- メソッド引数もローカル変数も final を付与して不変にする

## 3.4 プログラム構造の問題解決に役立つ設計パターン

- 完全コンストラクタ
- 値オブジェクト
- 「値オブジェクト + 完全コンストラクタ」は、カプセル化の最も基本形を体現している構造のひとつ

# 第4章　不変の活用 安定動作を保障する

- ローカル変数も引数も不変（再代入不可）にする
  - 同じインスタンスの使い回しをやめる
- 大量データの高速処理や画像処理、リソース制約の厳しい組込みソフトウェアなどで可変が必要なことがあります
- パフォーマンス以外で可変にして良いのは、スコープが局所的なケースです。ループカウンタなど、ループ処理のスコープでしか使われないことが確実なローカル変数ならば、可変にしてよいと考えます。

### 4.2.3 副作用のデメリット

- 副作用とは、関数が引数を受け取り、戻り値を返す以外に外部の状態を変更すること
  - インスタンス変数の変更
  - グローバル変数の変更
  - 参照型引数の変更
  - ファイルの読み書きなどの I/O 操作

- コード外とのやりとりには注意が必要
- コードの外の状態に依存すると、見通して見る

# 第5章 バラバラなデータとロジックをカプセル化する実践技法

- プリミティブ型を乱用しない
  - データのありかと制御ロジックの場所がバラバラになりがち
- static メソッドを乱用しない
  - カプセル化できない（データとデータ操作するロジックが乖離）
  - インスタンス変数、メソッドを使う
- インスタンスメソッドのふりしたstaticメソッドもある
  - 見分ける方法はstaticをつけてみること
- Common や Utils は  static と同じ問題抱えがち
  - 共通処理用のメソッドはstaticメソッドとして実装されがち
- オブジェクト指向設計の基本に基づいて設計しよう 
- **横断的関心事**…様々なユースケースで広く横断する処理は static でも問題ない
  - ログ出力（Logger）
  - エラー検出
  - デバッグ
  - 例外処理
  - キャッシュ
  - 同期処理
  - 分散処理
- 結果を返すために引数を使わない
  - C#のoutキーワードは次に示すTryParseメソッドのように、汎用的な変換用途などに限定する
  - カプセル化に問題が生じる場合は使用しない
- 引数が多すぎるのも良くない
  - 引数が多い場合は、意味がある単位ごとにクラス化する
- ```.``` で数珠つなぎで階層構造でアクセスするのはNG
  - 関連ロジックがバラバラになる良くない書き方
  - 例：```party.members.get(memberId).equipments.armor = newArmor;```
  - **デメテルの法則に違反**
    - 「知らない人に話しかけるな」

# 第6章　関心の分離という考え方 —分けて整理する—

- **関心の分離**
  - それぞれの関心をモジュールに分けて、他の関心の分離する考え方
  - カプセル化と密接な関係
- うまく別クラスに分離するためには、インスタンス変数とメソッドがどこと関連づいているか把握することが大事
  - 関係していそうなロジックを1つまとめたけど、徐々に肥大化しがち
    - **目的ごとに分離し、カプセル化する、という設計が関心を上手く分離する上で重要**
- **インターフェースと実装の分離**
  - 実装パートのインスタンス変数やロジックをモジュールの外に見せない
  - モジュール間はインターフェースを呼び出すだけ
    - メリット①：注意の負荷軽減 = ロジックが隠されたので注意を払う場所が減る
    - メリット②：仕様変更に強くなる = ロジック変更しやすい

# 第7章　関心が混ざったコードを分けて整理する実践技法

- ロジックを流用すると異なる関心が混在しがち
- **単一責任の原則**：クラスが担う責任は1つに限定すべき
  - 同じようなロジックが複数あるからといって、責任を考えずに無理やりひとまとめにするのはNG
  - 同じようなロジックでも、目的が違うロジックは共通化しない
  - **共通化していいのは、目的が同じときだけ**
- **継承は推奨しない**
  - サブクラスはスーパークラスに依存（スーパークラス依存）
  - サブクラスはスーパークラスを常に機にする必要あり
- **継承ではなく委譲**
  - スーパークラスではなく private なインスタンス変数として扱う = **コンポジション構造**
  - 下手に継承を使わずに丁寧にカプセル化、関心を分離することが重要
- **なんでも public にしない**
  - アクセス修飾子は適切に制御しないと、メンテナンスが困難になっちゃう
- **private だらけのクラスも注意**
  - private が多いクラスは、さまざまな関心を持っている可能性が高い
    - 異なる関心のロジックを private メソッドで実装している
- **表示と表示以外をそれぞれ別のクラスに分離する**
  - 新デザインに差し替えるとき大変になる
- **巨大データクラス**
  - 何も考えずに実装すると、さまざまなデータの置き場所になって巨大なデータクラスになる
  - グローバル変数と同様の弊害が起きがち
- **神クラス**
  - 1クラスに何千何万行も記述されて、あらゆるロジックが絡み合うようなクラス
- **巨大データクラスも神クラスも、カプセル化と関心の分離で設計することで対処**

# 第8章　条件分岐 —迷宮化した分岐処理を解きほぐす技法—

- `interface` を使って機能を取り替えるテクニックが重要
- 早期 `return` （ブロック節）で、ネストが深くならないようにする
  - `else` も `else if` も早期 `return` で読みやすくなる
- `switch` 文も良くない
  - 同じ条件の `switch` 文は増殖しがち
  - `case` 文の追加漏れが起こりうる
  - 単一責任の原則にならって、条件分岐を1箇所にまとめる
  - `interface` を使うことで構造をシンプルにできる
- **ストラテジーパターンも有効**
  - `switch` と違って実装漏れに気づきやすい
     - 目的別に異なる型の値オブジェクトを用意すると値の受け渡しミスを防げる

