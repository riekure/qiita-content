# 第2章 設計の初歩

- 省略せずに意図が伝わる名前付けをする
- 変数は使い回さない
- 目的ごとにメソッド化
- 関連するデータとロジックはクラスにまとめる = カプセル化

# 第3章 カプセル化の基礎 - ひとつにまとめる

- カプセル化
  - データとそのデータを操作するロジックをひとつにまとめる
- 関心の分離
- 多態性による機能の取り換え

## 3.1 クラス単体で正常に動作するように設計する

- データ単体のクラスだと正常動作は無理
  - クラス単体で動くように設計する
- ドメインモデルの完全性
  - データやロジックに欠損や不整合がなく、正確な状態を維持できること
- 貧血ドメインモデル
  - わざわざ他のクラスに初期化してもらったり、データをチェックしてもらったり、ほかのクラスのメソッドを呼び出さないと機能しないようなデータクラス
- 値の渡し間違いは型で防止
- 整数は int , 文字列は string にしがち
  - Money 型みたいな独自の型に使う
- システムの仕様に必要なメソッドのみを定義
- メソッド引数もローカル変数も final を付与して不変にする

## 3.4 プログラム構造の問題解決に役立つ設計パターン

- 完全コンストラクタ
- 値オブジェクト
- 「値オブジェクト + 完全コンストラクタ」は、カプセル化の最も基本形を体現している構造のひとつ

# 第4章　不変の活用 安定動作を保障する

- ローカル変数も引数も不変（再代入不可）にする
  - 同じインスタンスの使い回しをやめる
- 大量データの高速処理や画像処理、リソース制約の厳しい組込みソフトウェアなどで可変が必要なことがあります
- パフォーマンス以外で可変にして良いのは、スコープが局所的なケースです。ループカウンタなど、ループ処理のスコープでしか使われないことが確実なローカル変数ならば、可変にしてよいと考えます。

### 4.2.3 副作用のデメリット

- 副作用とは、関数が引数を受け取り、戻り値を返す以外に外部の状態を変更すること
  - インスタンス変数の変更
  - グローバル変数の変更
  - 参照型引数の変更
  - ファイルの読み書きなどの I/O 操作

- コード外とのやりとりには注意が必要
- コードの外の状態に依存すると、見通して見る

# 第5章 バラバラなデータとロジックをカプセル化する実践技法

- プリミティブ型を乱用しない
  - データのありかと制御ロジックの場所がバラバラになりがち
- static メソッドを乱用しない
  - カプセル化できない（データとデータ操作するロジックが乖離）
  - インスタンス変数、メソッドを使う
- インスタンスメソッドのふりしたstaticメソッドもある
  - 見分ける方法はstaticをつけてみること
- Common や Utils は  static と同じ問題抱えがち
  - 共通処理用のメソッドはstaticメソッドとして実装されがち
- オブジェクト指向設計の基本に基づいて設計しよう 
- **横断的関心事**…様々なユースケースで広く横断する処理は static でも問題ない
  - ログ出力（Logger）
  - エラー検出
  - デバッグ
  - 例外処理
  - キャッシュ
  - 同期処理
  - 分散処理
- 結果を返すために引数を使わない
  - C#のoutキーワードは次に示すTryParseメソッドのように、汎用的な変換用途などに限定する
  - カプセル化に問題が生じる場合は使用しない
- 引数が多すぎるのも良くない
  - 引数が多い場合は、意味がある単位ごとにクラス化する
- ```.``` で数珠つなぎで階層構造でアクセスするのはNG
  - 関連ロジックがバラバラになる良くない書き方
  - 例：```party.members.get(memberId).equipments.armor = newArmor;```
  - **デメテルの法則に違反**
    - 「知らない人に話しかけるな」

# 第6章　関心の分離という考え方 —分けて整理する—

- **関心の分離**
  - それぞれの関心をモジュールに分けて、他の関心の分離する考え方
  - カプセル化と密接な関係
- うまく別クラスに分離するためには、インスタンス変数とメソッドがどこと関連づいているか把握することが大事
  - 関係していそうなロジックを1つまとめたけど、徐々に肥大化しがち
    - **目的ごとに分離し、カプセル化する、という設計が関心を上手く分離する上で重要**
- **インターフェースと実装の分離**
  - 実装パートのインスタンス変数やロジックをモジュールの外に見せない
  - モジュール間はインターフェースを呼び出すだけ
    - メリット①：注意の負荷軽減 = ロジックが隠されたので注意を払う場所が減る
    - メリット②：仕様変更に強くなる = ロジック変更しやすい

# 第7章　関心が混ざったコードを分けて整理する実践技法

- ロジックを流用すると異なる関心が混在しがち
- **単一責任の原則**：クラスが担う責任は1つに限定すべき
  - 同じようなロジックが複数あるからといって、責任を考えずに無理やりひとまとめにするのはNG
  - 同じようなロジックでも、目的が違うロジックは共通化しない
  - **共通化していいのは、目的が同じときだけ**
- **継承は推奨しない**
  - サブクラスはスーパークラスに依存（スーパークラス依存）
  - サブクラスはスーパークラスを常に機にする必要あり