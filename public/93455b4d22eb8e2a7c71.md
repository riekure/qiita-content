---
title: Clean Codeメモ
tags:
  - Java
  - 学習
private: true
updated_at: '2019-10-29T11:33:08+09:00'
id: 93455b4d22eb8e2a7c71
organization_url_name: null
slide: false
ignorePublish: false
---
#第2章　意味のある名前
##意図が明確な名前にする (P.43)
- 変数の名前は、何の値が入っているのかはっきりと分かるものにする。

##偽情報を避ける (P.45)
- List じゃないのに `xxxxList` のような名前をつけてはいけない。
- 複数の意味を持ち、読み手に誤解を招くような単語や略語は使ってはいけない。
- 長い名前の一部だけが異なるような名前を付けてはいけない（例：`XYZControllerForEfficientHandlingOfStrings` と `XYZControllerForEffecientStorageOfStrings`）

##意味のある対比を行う (P.47)
- 対比される対象がある場合に、違いがはっきりと分かる名前を付ける。
    - 同一スコープ内の変数に `name1`、 `name2` のような名前を付けてはいけない。
    - ２つのクラスに `ProductInfo`、 `ProducetData` のような名前を付けてはいけない。
    - ２つのメソッドに、 `getAccount()` と `getAccountInfo()` のような名前を付けてはいけない。

##発音可能な名前を使用する (P.48)
- 人間が自然と発音できる名前を使用する。
- この本では、実在した例として `genymdhms()` という名前を挙げている。
    - `generate year month day hour minute second` の略で、読みは「ジェン　ワイ　エム　ディー　エイチ　エム　エス」。

##検索可能な名前を用いる (P.49)
- grep などで目的の箇所を検索しやすい名前にする。
- 一文字の変数などは検索しづらい。
- マジックナンバーは検索しづらい。
    - 数字の 5 で grep する場合と、 `WORK_DAYS_PAR_WEEK` で grep する場合だと、後者の方が目的の箇所を検索しやすい。

##エンコーディングを避ける
- エンコーディングとは、型やスコープの情報を変数やメソッドの名前に含める手法のこと（`_privateMember`、`i_value` のようなの）。

###ハンガリアン記法 (P.50)
- Java などの明確な型が宣言できる言語では、ハンガリアン記法は使用しない。

※ ハンガリアン記法とは？
int 型だから変数名の先頭に ```i``` をつける記述スタイル

```java
int iCount;
unsigned int uiNumber;
```

###メンバープレフィックス (P.51)
- メンバー変数であることを表すメンバープレフィックスは使用しない。

###インターフェースと実装 (P.52)
- インターフェースの名前の先頭に `I` を付けない。

##メンタルマッピングを避ける (P.52)
- 別の人がコードを読んだ時に、「`a` は `account` のことだな」のような脳内変換（メンタルマッピング）が必要になる名前を付けてはいけない。

##クラス名 (P.53)
- クラス名は名詞で名付ける。
- Manager, Processor, Data, Info のような単語の使用は避ける。
- クラス名を動詞にするのは避ける。

##メソッド名 (P.53)
- メソッド名は動詞で名付ける。
- コンストラクタがオーバーロードされている場合、 static なファクトリメソッドを検討する。

##気取らない (P.54)
- 俗語や、一部の人にしか通じないようなジョークを交えた名前を付けてはいけない。

##１つのコンセプトは１つの単語 (P.54)
- 例えば、何らかの値を取得するメソッドの名前が、クラスによって `get` だったり `retrieve` だったり `fetch` だったりするのを避け、同じ名前を付けるようにする。

##ごろ合わせをしない (P.55)
- １つの単語に２つ以上の意味を持たせてはいけない。
- 例えば、以下のような異なる意味を持つ add メソッドを作ってはいけない。
    - ある add メソッドは、第一引数のオブジェクトに第二引数の値を追加する。
    - ある add メソッドは、そのオブジェクトに引数で指定した値を追加する。
- 既に存在するメソッドの大部分が前者だった場合、後者は `append` と名付けた方が良い。

##解決領域の用語の使用 (P.55)
- 解決領域の名前に、コンピュータサイエンスの用語・アルゴリズムの名前・パターンの名前・数学用語を用いるのは全く問題ない。
- 解決領域を全て業務用語で名付けるのは避ける。

##問題領域の用語の使用 (P.56)
- 問題領域の名前は、業務用語から名付ける。

##意味のある文脈を加える (P.56)
- それ単独だと文脈がわかりづらい変数がある場合、適切なクラスや関数、名前空間に属させる。
- 例えば、 `name` という変数が使用されているとき、それだけでは「何の名前か？」がわかりづらい。
- `name` が管理者の名前だとした場合、 `Administrator` クラスの中に移したり、管理者を操作する小さな関数の中に移動することで「管理者の名前」という文脈が分かりやすくなる。

##根拠の無い文脈を与えない (P.58)
- 必要以上に、名前に文脈を付けてはいけない。
- 例えば、あるシステム ABC に含まれるクラスだからといって、その全てのクラス名の先頭に ABC を付けるようなことは、してはいけない。
- 長い名前より、短く意味が明確な名前の方が優れている。

#第3章　関数
##小さいこと！ (P.64)
- 関数の第一規則は、小さくせよ。第二の規則は、__さらに小さくせよ__。
- 関数の長さが20行に達することなど、ほとんどないようにすべき。
- 理想は１関数 2～5 行程度。

##ブロックとインデント (P.65)
- 理想の行数を実現しようとした場合、必然的に if 文などのブロックは入れ子にしてはいけないことが示唆される。
- 必然的に、ブロックの中は分割した別の関数の呼び出しになる。

##１つのことを行う (P.65)
- 関数では１つのことを行うようにせよ。その１つのことをきちんと行い、それ以外のことを行ってはならない。
- 「１つのこと」とは、「同じ抽象レベルで行う一連の処理」のこと。
- 関数を書く目的は、ある抽象レベルの１つの処理を、次のより詳細な抽象レベルのいくつかのステップに分解することにある。

##関数内のセクション (P.67)
- ある関数の中身を、いくつかのカタマリ（セクション）に分類できる場合、その関数は１つ以上のことをしている。
- １つのことをしている関数は、セクションに分けることが難しくなる。

##１つの関数に１つの抽象レベル (P.67)
- １つの関数の中にある各ステップは、すべて同じ抽象レベルの処理にする。
    - **HTML単位なのか、パス名単位なのか、改行コード1つのことなのか…**

##コード通読：逓減（ﾃｲｹﾞﾝ）規則 (P.67)
- 関数は、 TO 節の並びとして読めるのが良い。
- TO <関数名> , <関数内の処理>
    - <関数名> するためには、 <関数内の処理> を行う。

##switch 文 (P.68)
- switch 文はポリモーフィズムで置き換える。
- ファクトリメソッド内のように継承の裏に隠された場所での switch 文の使用は許容できる。

##内容をよく表す名前を使う (P.70)
- 関数の中で何を行っているかがよく分かる名前を付ける。
- 関数が小さいほど、名前を付けるのが簡単になる。
- 内容をよく表す長い名前は、不可解な短い名前よりも優れている。
- 内容をよく表す長い名前のほうが、内容を説明した長いコメントよりも優れている。

##関数の引数 (P.71)
- 関数の引数の理想は、０（無し）。
- ３つ以上の引数は避ける。４つ以上はよほどの理由がない限り避ける。

###共通モナディック形式 (P.72)
- １引数の関数には、以下の一般的な形式がある。
    - 受け取った引数について判定し、 boolean を返す形式。
    - 受け取った引数を変換し、別の値を返す形式。
    - イベントが発生したときに呼び出される関数の形式。イベントに関する情報が引数で渡され、戻り値は無い（void）。
- これらの形式とは異なる動きをする関数は、作ってはいけない。

###フラグ引数 (P.73)
- フラグ引数は使ってはいけない。
- true/false の場合で、それぞれ関数を定義すべき。

###引数２つの関数 (P.73)
- ２つの引数が、２つセットであることが自然である場合（デカルト座標など）は、引数２つの関数も問題ない。
- 引数が２つある関数が存在した場合、１つにできないか検討する。

###引数３つの関数 (P.74)
- 引数３つの関数は、引数２つよりも理解が難しい。

###引数オブジェクト (P.74)
- 引数が多い場合、同じ概念の引数はそれらをまとめたクラスにラップする（引数オブジェクト）。

###引数リスト (P.74)
- 可変長引数が全て同じ用途で使われている場合、それは１つの List の引数とみなすことができる。
- 可変長引数のそれぞれを異なる用途で使う場合、それは２つ以上の引数が存在するのと同じになり、避けるべき。

###動詞とキーワード (P.75)
- 関数名には、引数を説明するキーワードを含めたほうが良い。
- `write(name)` よりも、 `writeField(name)` の方が良い。

##副作用を避ける (P.76)
- 副作用とは偽りです。
- 関数が１つのことを行うことを保証しつつ、隠れて別のことを行うのです。

###出力引数 (P.76)
- 出力引数は避けるべき。
- 関数が何らかの状態を変更しなければならないのであれば、自分自身の状態を変更すべき。

##コマンド・照会の分離原則 (P.77)
- １つの関数は、以下のいずれかのみを行うべき。
    - 何らかの処理を行う（コマンド）
    - 何らかの応答を返す（照会）
- １つの関数が、コマンドと照会の両方を行うべきではない。

##戻りコードよりも例外を好む (P.78)
- エラーがある場合、エラーコードを返すのではなく例外をスローする方が良い。

##try/catch ブロックの分離 (P.79)
- try ブロック、 catch ブロックをそれぞれ単一の関数に抽出する。

###エラー処理も１つの処理 (P.80)
- エラー処理も１つの関数として抽出する。
- エラー処理の関数は、エラー処理以外を行ってはいけない。

###Error.java依存性磁石 (P.80)
- エラーコードを返す関数を作っている場合、エラーコードをまとめた enum が存在することになる。
- この enum はあらゆるクラスから依存される磁石のような存在になる。

##DRY(Don't Repeat Yourself)原則 (P.81)
- 重複は排除すべし。

##構造化プログラミング (P.81)
- 関数が十分に小さければ、複数の return や break、 continue の存在は問題にならない。
- 関数が十分に小さければ、 goto 文は不要になる。

##なぜ関数をこのように書くのでしょう？ (P.82)
- プログラムを書くことは、文章を書くことと同じ。
- 最初の草稿はぎこちないが、読者が読みたいと思えるような文章になるまで推敲を重ねる。
- 最初から完璧なものが書けるわけがない。そんなことは誰にもできない。

#第４章　コメント
##コメントで、ダメなコードを取り繕うことはできない (P.89)
- コメントを書くことに時間をかけるより、その時間をコードを綺麗にすることに費やすべき。

##自分自身のコードの中で説明する (P.89)
- コメントで説明するのではなく、変数名や関数名から読み取ることができるように名前を付ける。

##よいコメント (P.89)

###まっとうなコメント (P.90)
- ライセンスや著作権のコメントは必要なコメント。
- ただし、本文は別途用意し、そこへの参照のみ記載するなどして、可能な限り短くすると良い。

###情報を与えるコメント (P.90)
- コードには記載されていない追加の情報を与えるコメントは有益となる。
- しかし、その追加情報をコードで表現すれば、コメントは結局不要になる。

###意図の説明 (P.91)
- 「何故そうしたのか？」のような意図の説明はコードで表現することができないので、補足としてコメントを残すのは有益。

###明確化 (P.92)
- 曖昧な情報や、解読が困難な実装に対して、意味を明確化するためのコメントは有益。
- ただし、これも曖昧ではない実装、可読性の高い実装にコードを修正すれば、コメントは不要になる。

###結果に対する警告（P.93）
- 例えば、あるメソッドの処理時間が非常に遅い場合、それを頻繁に使用しないよう警告のためにコメントを記載するのは有益。
- ただし、可能な限り使用するフレームワークやライブラリがサポートしている方法で警告を明示するほうが良い（JUnit の `@Ignore` など）

###TODOコメント(P.94)
- あとでやるという覚書を残すためには有益。
- TODOコメントを発見した場合は、なるべく潰すようにする。

###強調(P.94)
- 不可解に思える実装についても、理由を説明するためのコメントは有益

###公開APIにおけるJavadoc(P.95)
- Java標準ライブラリのJavadocを参考にする。
- Javadocで誤解を招いてしまうコメントは避ける。

##よくないコメント
###ぶつぶついう(P.95)
- 他人が見て意味のわからないコメントは残さない。

###冗長なコメント(P.96)
- コードを読めば分かることを、コメントに書かない。

###誤解を招くコメント(P.99)
- コードより読みづらいコメント、誤解を招くコメントは書かない。

###命令コメント(P.99)
- すべての変数にコメントを強制するようなルールは馬鹿けている。
- コードをわかりにくくして、嘘と間違いを生成することになる。

###日誌コメント(P.100)
- バージョン管理できるので、変更履歴は不要。

###ノイズコメント(P.100)
- 「デフォルトコンストラクタ」といった、変数名や定義を見て分かるコメントは不要。

###恐るべきノイズ(P.103)
- ソースコード以上の情報がないのであれば、Javadocも不要。

###関数や変数が使用できるのであれば、コメントは使用しないこと(P.103)
- コメントでだらだらと説明するくらいならば、関数や変数を使用して書き直すべき。

### 道標(P.104)
- ```// Actions ////////////////////``` といったバナーは、背景の雑音になるため不要。

### 閉じカッココメント(P.104)
- 閉じカッココメントは不要。（下記のようなもの）

```java
try {

} // tryする
catch {

} // catchする
```

### 属性と署名(P.105)

- 下記のような誰がいつ追加したかなどの情報は、バージョン管理が記録しているため不要。

```
/* Added by Kikuchi */
```

### コメントアウトされたコード(P.105)

- コードのコメントアウトは残さず、削除する。
- いざというときは、バージョン管理から復元できる。

```java
int i = 0;
// InputStream is = new FileInputStream("text.txt");
```

### HTMLコメント(P.106)

- コメントで大量のHTMLの記述は避けるべき。

### 非局所的な情報(P.107)

- コメントを書く場合は、対象となるコードの近く。
- システム全体に関する情報を局所的なコメントにしない。

### 多すぎる情報(P.107)

- 過度に詳細なコメントは不要。

### 不明確なつながり(P.108)

- コメントとコードをみて、コメントが何について述べているか理解できるようにする

### 関数ヘッダ(P.108)

- 短い関数にコメントは不要。
- 小さくして、1つのことを行うようにすれば、コメントは不要。

### 非公開コードのJavadoc(P.109)

- 外部に非公開で、使われることがないコードのJavadocは不要。

# 第5章　書式化

## 縦方向の書式化(P.116)

- 大抵の場合、200行から500行程度のファイルで構成されている。
- 大きいファイルより、小さいファイルの理解が容易。

### 新聞にたとえる(P.117)

- 新聞の場合、一番上に見出しがあり、下に進むと詳細が分かる。
- ソースコードの場合、名前だけ見れば、自分が見たいモジュールかどうか判断できる。
- 一番最初は、高レベルの概念とアルゴリズムが書かれているべき。
- 一番下は、最も低レベルの関数と詳細な記述。

### 垂直概念分離性(P.118)

- パッケージ宣言、インポート宣言、各メソッドの間に空行を入れると見やすくすることができる。

### 垂直密度(P.119)

- 強く関連している変数は、間に空行や無駄なコメントを挟まないようにする。

### 垂直距離(P.120)

- 変数を宣言するときは、その変数が使用される場所となるべく近い位置で行う。
- ループの制御変数は、ループ文内で宣言する。

```java
int count = 0;
for (Test each : tests)
    count += each.countTestCases();
```

- インスタンス変数（メンバ変数）は、クラスの頭で宣言するべき。
- インスタンス変数（メンバ変数）は、非常に多くのメソッドで使用されるため、よく知られた場所に置くことが必要。

```java
class Sample {
    private String message;
}
```

- ある関数が別の関数（メソッド）を呼んでいる場合、垂直方向に近い位置に置くべき。
- 可能なかぎり、呼び出し側で呼び出される側の上に置くべき。
- 一番上の関数は、その下にある関数を呼び、その関数が順番に下の関数を呼ぶ（階層構造）

- 共通の命名体系のものは、依存関係がなくとも、すぐそばに置く必要がある。

### 垂直方向の並び順

- 関数は、呼び出す側が上、呼び出される側が下にくるべき。

## 横方向の書式化(P.126)

- 横方向は80文字〜120文字程度に抑える。

### 水平分離性と密度(P.127)

- 変数の代入文は、スペースを使って左辺と右辺を明確に分離する。
- 関数とその引数の間のスペースは不要。

```java
int lineSize = line.lengh();
lineWidthHistogram.addLine(lineSize, lineCount);
```

- 演算の優先順位を明確にすることができる。
  - 掛け算のほうが足し算よりも優先度が高いことを、スペースの有無で表現できる（自動フォーマット機能でスペースが挿入されてしまう場合あり）

```java
int count = b*b - 4*a*c;
```

### 水平方向の位置合わせ(P.128)

- 水平方向の位置合わせはしない。
- 変数の総数を減らすことができないか検討する。

```java
private int    i    = 0;
private String str  = "test";
private Date   date = new Date();
```

### インデント(P.130)

- インデントを適切に入れることで、人間に読みやすいコードになる。

### ダミーのスコープ(P.132)

- 下記のような記述は避ける。

```java
while(dis.read(buf, 0, readBufferSize) != 1)
    ;
```

## チームの規則(P.132)

- チーム内の開発者は、1つの書式設定に従うべき。
    - 各々が好き勝手にコードを書いてはいけない。


## アンクルボブの書式化規則(P.133)


# 第6章　オブジェクトとデータ構造

## データ抽象化(P.137)

- private変数と、それに対するゲッタとセッタを用意することは、公開することに近い。→隠蔽できていない
    - データをそのまま公開したいわけではなく、データを抽象化（加工）された形式で表現したい。
    - 軽い気持ちでゲッタとセッタを用意するのは最悪。

## データ/オブジェクトの非対称性(P.139)

- データ構造は、データのみを紹介して、意味を持った機能は何も提供しない。
- オブジェクトは、データ構造を隠蔽して、抽象化された操作を提供する。

--- 
- オブジェクト指向で難しいことは手続き型では容易、手続き型で難しいことはオブジェクト指向では容易。
    - オブジェクト指向では、既存の操作関数に影響を与えず、新しい操作関数を追加することができる。
    - 手続き型では、既存のデータ構造に影響を与えず、新しい関数を追加できる。
    - オブジェクト指向では、新しい操作関数を追加すると、既存のデータ構造をすべて変更しなければならない。
    - 手続き型では、新しいデータ構造を追加すると、既存の操作関数をすべて変更しなければならない。


## デメテルの法則(P.142)

- オブジェクトはアクセサを通して内部のデータ構造を公開してはならない。
    - 内部構造を隠すのではなく、公開することになる

- デメテルの法則とは…
    - オブジェクトの"メンバーのプロパティ/メソッド"を直接触らないようにするということ。

```java
// デメテルの法則に違反している
console.log(aStudent.class.grade)

// デメテルの法則に違反していない
console.log(aStudent.getGrade())
```

### 電車の衝突(P.143)

コードがあたかも連結された車両に見える＝電車の衝突と呼ばれることがある

```java
String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```

以下のように分けるのがよい

```java
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```

### 混血児(P.144)

- publicな変数あるいは、publicなアクセサとミューテータ（データメンバにアクセスするためのメンバ関数）を用意することで、private変数をpublicにすることと同じことが行われ、外部関数に対し、データ構造として、これらの変数に手続き的にアクセスすることをうながす
- 抽象的なメソッドを持ちながら内部構造を公開する、オブジェクトとデータ構造を混ぜあわせたようなクラスを「混血児」と呼ぶ。
- 混血児はNG

### 隠蔽構造(P.144)

## データ転送オブジェクト(P.145)

- 典型的なデータ構造クラスは関数を持たずにpublic変数のみ持ったもの＝DTO（データ転送オブジェクト）
    - データベース、あるいはソケットから取得したメッセージのパーシング（解析）に便利
    - アプリケーションコードの中の、データベースから読み込んだ生データを変換していく過程の最初の段階
- ビーンは、private変数がゲッタとセッタで操作。

### アクティブレコード(P.146)

- アクティブレコード＝DTOの特殊形態＝public変数を持ったデータ構造だが、```save```や```find```といったナビゲーション用の典型的なメソッドを持っている
- アクティブレコードに、ビジネスロジックをもたせてはいけない。
    - ビジネスルールをもったオブジェクトを別に用意すること
    - 内部データ（アクティブレコードのインスタンス）はオブジェクトの中に隠蔽

# 第7章　エラー処理(P.150)

## リターンコードではなく、例外を使用する(P.150)

- エラーがあった場合は、例外を送出するほうがよい

### 最初にtry-catch-finally 文を書く(P.152)


### 非チェック例外を使用する(P.153)

- 一般的なアプリケーション開発では、チェック例外ではなく非チェック例外を使うのが良い。

- 非チェック例外
    - Runtime Exception配下の例外クラスが対象。
    - try-catchで例外ハンドリングする必要はない
- チェック例外
    - Exceptionクラス配下のRuntime Exception以外のクラス
    - Javaがコンパイル時に検査を行う例外なので、try-catchで例外ハンドリングを行わないといけない

## 例外で状況を伝える(P.154)

- 十分な情報をもったエラーメッセージを作成し、例外に含める。
    - 失敗した処理、失敗した処理を含める。
    - catchした場所でロギングを行うために重要な情報を渡す

## 呼び出し元が必要とする例外クラスを定義する(P.154)

- 特定の領域のコードでは、1つの例外クラスを使用する。
    - 例外とともに送られる情報によって、エラーを判別することが可能。
- 例外をキャッチしたいが、別の例外はキャッチしたくないケースがある場合のみ、別のクラスを使う。

```java
public void open() {
  try{
    innerPort.open();
  } catch (DeviceResponseException e) {
    throw new PortDeviceFailure(e);
  } catch (ATM1212UnlickedException e) {
    throw new ProtDeviceFailure(e);
  } catch (GMXError e) {
    throw new PortDeviceFailure(e);
  }
}
```

## 正常ケースのフローを定義する(P.156)

- 例外をキャッチした後も処理は継続するような場合は、例外を送出するのではなくマーチン・ファウラーのスペシャルケースパターンの利用を検討する。

## nullを返さない(P.158)

- 関数ではnullを返さない
    - リストを返す関数ならば、空のリストを返すように
    - APIがnullを返すならば、メソッドをラップして代わりに例外を送出するか、スペシャルケースオブジェクトを返す

イミュータブル ＝ 変更不可

## nullを渡さない(P.159)

- 呼び出し元から```null``` を渡さない
    - ```null``` を渡すことを原則禁止
    - こうすると、```null``` が引数に渡されることは、間違いとすることができる

# 第8章　境界

## サードパーティーのコードを使用する(P.164)

- サードパーティのコードを使用する場合は、APIを限定したラッパークラスを用意するほうがよい

以下、Mapを利用して、SensorのMapを作成したい場合の例

```java
public class Sensors{
  private Map sensors = new HashMap();

  public Sensor getById(String id) {
    return (Sensor) sensors.get(id);
  }
}
```

## 境界の調査と学習(P.166)

- サードパーティのコードを使用する場合、テストコードを書いてみるとよい
- こうしたテストを学習テストと呼ぶ

## log4jを学習する(P.167)

## 学習テストは、タダ以上のものである(P.169)

- 理解を深めることができる
- サードパーティのパッケージの新バージョンがリリースされたとき、変更されているかどうかテストすることができる

## まだ存在しないコードを使用する(P.169)

- 我々自身が欲しいインターフェースを定義する
- 期待するインターフェースをもとに実装を進める
- 存在しなかったサードパーティのコードが作成されたあと、期待するインターフェースと実際の実装を吸収するアダプタクラスを作成して、統合できる

## きれいな境界(P.171)

- サードパーティの境界を管理するために、コード内に非常に小さな領域を設け、そこからサードパーティのコードに問い合わせを行う。
- Mapでラップするか、あるいはアダプタを使うことで、自分が作成した完璧なインターフェースから提供されるインターフェースへ変換することが可能となる

# 第9章　単体テスト

## TDD三原則(P.174)

- TDD三原則
    - 第一原則：失敗する単体テストコードを書く前に、製品のコードを書いてはならない
    - 第二原則；コンパイルが通り、適切に失敗する単体テストができるまで、次の単体テストを書いてはならない
    - 第三原則：現在失敗している単体テストが通るまで、次の製品コードを書いてはならない
- テストコードと製品コードは同時に書く
    - テストコードのほうを数秒先行する

## テストをきれいに保つ(P.175)

- テストコードも、製品コードと同様に重要で、製品コードとおなじようにきれいに保たなければならない
    - テストコードが不十分だと、とある変更がシステムの別部分を壊していないか確認することができない
        - 不具合発生率の上昇
    - 偶発的な不具合が増え、製品コードをきれいにしなくなった

## テストは、xxx性を可能とする(P.176)

- テストがあれば、変更を恐れずに行うことができる
- テストが汚いとコード変更の®妨げとなる

## クリーンテスト(P.177)

- テストを読みやすくするコード
    - 明瞭さ
    - 単純さ
    - 表現の密度
- 構築ー操作ー検査パターン
    - テストデータを構築
    - 構築したデータに操作を行う
    - 操作結果が期待される内容になっているかどうか確認

### ドメイン特化テスト言語(P.180)

- APIを使った関数とユーティリティを作成して、もっと簡単に読み書きできるようにする
    - これらの関数とユーティリティは、テスト特化のAPI ＝ テスト言語

### 二重規範(P.180)

- 本番環境では書けないコードでも、テスト環境であれば問題ない場合がある。
    - メモリ、CPUの使用率など
- StringBufferを使用するか、単純な```+=```による文字列結合を実行するかの選択の場合、可読性を重視して```+=``` を使用してもよい。

### 1つのテストに1つのアサート(P.183)

-  アサート文はなるべく少なくすべき。
-  2つ以上のアサートを含めても構わない（筆者の考え）
    -  1つのJUnitテストには、1つアサート文までは厳しすぎるかも

### 1つのテストでは1つの概念を扱う(P.184)

- 1つの関数では、1つの概念についてのみ扱う
- 例）addMonths()メソッドのテストの場合
    - 最終日が31日である月（たとえば5月）の最終日
    - 最終日が30日である月の最終月
    - 最終日が28日である月（2月のみ）の最終月

## F.I.R.S.T(P.186)

- 高速である（Fast）
    - テストが頻繁に実行できるように
    - 実行が遅いと、実行することや綺麗にすることが億劫になる
- 独立している（Independent）
    - 1つのテストに失敗して、後続のテストが実行されないということがないようにする
- 再現性がある（Repeatable）
    - 本番環境でもステージングでも、ネットがつながらないローカル環境でも実行できるようにする
- 自己検証可能（Self-Validating)
    - 成功か失敗のどちらかを出力するようにすべき
    - 長いファイルを読んだり、2つのテキストファイルを見比べないとテスト結果がわからないようなものは避ける
        - 失敗の判定が属人的になってしまう
- 適時性がある（Timely）
    - 製品コードを書く直前に単体テストを書く

# 第10章　クラス

## クラスの構成(P.189)

Javaの標準コーディング規約での順番
1. public static定数
2. private static変数
3. privateなインスタンス変数
4. publicな関数
5. privateなユーティリティ関数

public→privateの順番が基本。

## カプセル化(P.190)

- 変数もユーティリティ関数もprivateにすることが筆者的好み。
    - テストからアクセス可能とするため、変数やユーティリティ関数をprotectedとする必要がある場合がある
    - カプセル化を緩めるという選択肢は、**最後の手段**

## クラスを小さくしなければならない！(P.190)

- クラス設計は、小さくすることが第一規則。
- クラスは責務の数を1つとする。（関数の場合は、2~5行程度）
- クラスの解説を行う際に、「もし」、「そして」、「あるいは」、「しかし」という単語を使わない。使わずに25文字以内で説明できる。

### 単一責務の原則(P.193)

- クラスは1つの責務＝変更の原因となるものを1つ
- 多目的の大きなクラスで構成すると、理解しなくてもよい部分まで調べることになる
    - 多数の小さなクラスで構成したほうがよい
- 生成と実行を分離
- 関心事の分離する

### 凝集性(P.194)

- クラスは限られた数のインスタンス変数を持つべき。
    - あるメソッドが操作する変数が多いほど、そのクラスの凝集性は高い。
    - 全変数が全メソッドに使用されているクラスが、一番凝集性が高いといえる。
- 凝集性は高いほうがよい
- **関数を小さく、引数を短く**という鉄則を守る ＝ **インスタンス変数が急増する可能性あり**
    - そのような場合は、クラスを分離できる ＝ クラスの凝集性を高めるべき

### 凝集性に気を配ると、大量のクラスが生まれる

- 別クラスに分けたときに、渡す引数が増えてしまうのでは？
    - クラスのインスタンス変数にして、コンストラクタで初期値を設定するほうがよい！

## 変更のために最適化する

- 単一責任の原則に従ってクラスを分割することで、OCP（開放/閉鎖原則、Open Closed Principle）を満たす
- 新規機能を加えるとき、機能の変更を行うとき、できる限り汚れ作業が少なくて済むように。
    - 新規機能は既存のシステムの拡張のみ。
    - 既存コードの変更はなし。

### 変更から切り離す

- クラスは抽象層にのみ依存すべきで、詳細な具象層に依存すべきではない = DOP（依存関係逆転の原則）
    - 具象クラスに依存するのではなく、インターフェース、抽象クラスに依存

# 第11章　システム

## あなたは、街をどうやって造りますか？

## システムを使うことと、構築することとを分離する(P.210)

- 「オブジェクトの生成」と「依存関係の解決」
- システムを構築するうえで必要になることは、システム本来の処理から分離すべき。
    - モジュール化して、通常のランタイム処理から切り離し、主要な依存関係（オブジェクト化、new）を解決するために包括的な整合性のとれた手順にすべき。
- 構築すること＝new（オブジェクト化）
- システムを使うこと＝ランタイムロジック
    - この2つは分離するべき。責務を1つにする

### mainの分離

- main関数を用意して、main内ですべての依存関係を解決するべき。
    - main関数がシステムに必要なオブジェクトを生成し、アプリケーションに渡して、それを使用する。

### ファクトリ

- オブジェクトの生成に対して、アプリケーションが責任を持たなければならない場合がある
    - 発注処理のシステム例：アプリケーションは発注に追加するための品目インスタンスを生成しなければならない
- その場合は、抽象ファクトリパターン（GOF,Abstract Factoryパターン）を活用する

### 依存性注入

- 依存性注入（DI）は、オブジェクトの利用と生成を分離する強力な仕組み。
- 依存性管理に対する、制御の反転の適用。
- 引数でクラスや変数を外から受け取れるようにする
- セッタやコンストラクタを使用する
- 依存性注入といわれたら、**コンストラクタ**を使う

## スケールアップ

- とあるビーンは別のビーンを継承することはできない。
- システムレベルでアーキテクチャのインクリメンタルな拡張を実現するためには、関心事を適切に分離しておく必要がある。

### 横断的関心事

- 永続化の手法を本質的に同じコードの繰り返しによって、多くのオブジェクトにまたがって、実装することになる ＝ 横断的関心事
    - 複数のオブジェクトをまたがって記述される
- アスペクト指向プログラミングを活用するとよいかも
    - 複数のクラスをコンパイルしたときに単一のクラスになるようなイメージ

Javaにおけるアスペクト、およびアスペクト的な仕組み

## Javaプロキシ

- 個々のオブジェクトやクラスのメソッドをラップしたいケースなど、単純な状況に適している。
    - JDKにある動的プロキシ（ダイナミックプロキシ）は、インターフェースでしか利用できない。
    - CGLIB, ASM, Javassistのようなバイトコード操作ライブラリが必要。


- ```Bank``` = プロキシ
- プロキシAPIは、InvocationHandlerオブジェクトを必要
- AOPを実現しようとすると、コード量が多くなってしまう
    - しかも複雑

## Pure JavaのAOPフレームワーク

AOP（アスペクト指向プログラミング）
- Spring AOPやJBoss AOPといったJavaフレームワークでは、プロキシを内部で使用して、アスペクトを実装している
- XMLについて、設定より規約とアノテーションを用いることで、最小限の記述ができる
- EJB3だと、Springのようなフレームワークにより、完全なPOJOを書くことができる

## AspectJアスペクト

- ほとんどの場合は ```Spring AOP``` や ```JBoss AOP``` で事足りるが、もし足りないという場合は、 ```AspectJ``` の強力な機能を利用する方法がある。
- AspectJ はツールに慣れるのがやや大変

## システムアーキテクチャのテスト実行

- POJOでドメインロジックを記述できれば、自分が構築したアーキテクチャのテスト実行が可能。
    - ドメインロジックがアーキテクチャの関心事から分離される
- 事前の大規模設計が不要（Big Design Up Front, BDUF）
    - そのため、必要に応じて新しい技術に対応することができる
- よりよいAPIは、ほとんどの場面で視界の外になければならない

## 意思決定の最適化をする

- 決定は、手遅れとなる直前まで延期することが最善
- 早すぎる決断は、最善とはいえない知識のもとに行われる

## 認証可能な価値を追加する際には、標準を賢く使用する

- 「標準」は、人類が蓄積してきた知識の再利用を容易にする
    - しかし、標準を決めることは時間がかかり、いざ使おうとすると本当のニーズとは異なる場合もある

## システムはドメイン特化言語を必要とする

- ドメイン特化言語（DSL）の作成が脚光を浴びている
    - 独自の小さなスクリプト言語、標準言語のAPI
    - ドメインの専門家が書くような散文構造のようにコードが読めるようになる
    - ドメインの概念とそれを実装するコードとの「コミュニケーションギャップ」を極小化する

# 第12章　創発

## 創発的設計を通して、洗練する

- 優れた設計を生み出すためには、
    - 全テストを実行する
    - 重複がない
    - プログラマの意図が表現されている
    - クラスとメソッドを最小化する

## 単純な設計への規則1：全テストを実行する

- テストができない、検証できないシステムは、配備するべきではない
- テスト可能にすると、クラスは小さくなっていく、細かくなっていく（単一責任の原則）
    - クラス同士の結びつきが強いと、テストが困難になる
- システムを完全にテスト可能とすることが、より優れた設計を生み出すことになる

## 単純な設計への規則2~4：リファクタリング

- テストがあれば、リファクタリングが容易
    - テストができれば、修正ミスを防ぐことができる

## 重複の排除

- 最大の敵：重複
    - たった数行の重複も取り除くべき。
    - 重複している部分をメソッドとして分離する
    - テンプレートメソッドパターンも有効

## 表現に富む

- 書き手の意図が明確に表現されている
    - 別の人が理解するために必要な時間を削減することができる
    - 保守コストを減らすことができる
- 意図を明確にするためには？
    - 関数とクラスを小さく保つ
    - 標準の用語を用いる（デザインパターン名など）
    - 単体テストを適切に記述する
        - 使用例を文書化することができる
        - テストを見れば、そのクラスがどういうものか、理解することができる

## クラスとメソッドは最小限に

- 重複の排除、コードの表現力、SRPは、行き過ぎてしまうことがある
- 関数とクラスを小さくすることは、他の規則に比べて優先度が低い
- 関数を小さくすることより、以下のほうが重要
    - テストを用意すること
    - 重複を排除すること
    - コードに自分の意図を表現すること

# 第13章　同時並行性

## なぜ同時並行性が必要なのか？

- 同時並行性とは、「何を実行するか」と「いつ実行するか」を分離するときに役立つ。
- 同時並行性のメリット
    - アプリケーションの構造とスループットを改善することが可能
        - 1つ大きなメイン処理ではなく、小さなコンピュータの集まりに見える。→理解が簡単になる。
    - 応答時間とスループットの制約を解決できるかも。
        - マルチスレッドを用いて、複数のサイトに同時にアクセスすることで、実行時間を改善することができる

### 神話と誤解

- 同時並行性は常にパフォーマンスを改善する
    - パフォーマンス改善できるが、待ち時間が大量にあり、複数のスレッドやプロセッサで共有できる場合のみ。
- 同時並行性プログラムを書く場合に、設計の変更は不要である
    - シングルスレッドと同時並行アルゴリズムはぜんぜん違う。
- Web, EJBといったコンテナで作業するのであれば、同時並行性の問題を理解することは対して重要ではない
    - 使用しているコンテナが何を行い、どのように同時更新と、デッドロック問題に対処しているかを理解するほうがよい


## 難問

- 同時並行性プログラムは、問題が起こるパターン（経路）が想定しにくい。
    - バイトコードでみると、実行経路がかなり多い。
    - 大半の実行経路では正しい結果を得られるが、一部の経路だけ間違った結果が得られてしまう。

## 同時並行性防御原則

### 単一責務の原則

- 同時並行性は、それだけで単一の責務といえる。
    - **同時並行性に関係するコードを、他のコードから分離すること**

### 帰結：データのスコープを限定せよ

- 複数のスレッドに共有されたオブジェクトを同時に変更すると、影響しあって予期せぬ挙動になる可能性がある。
    - 失敗の原因を見つけづらくなる
    - 保護を入れ忘れる→共有データを簡単に破壊できる
    - ちゃんと保護されているか、確認する努力が面倒
    - 解決策：``` synchronized``` キーワード

- **データのカプセル化を徹底。共有される可能性があるデータへのアクセスは厳しく制限**

### 帰結：データのコピーを使用せよ

- そもそもデータ共有しない
    - データをコピーして、読み出し専用のものとする方法がとれる場合がある
    - オブジェクトをコピーし、複数のスレッドの結果をコピーしたオブジェクトに集めて、1つのスレッドでマージする。

### 帰結：スレッドはできるかぎり独立させよ

- 各スレッドがデータを共有しない、ローカル変数のみで完結れば、同期する必要がなくなり、別プロセッサで処理することも可能となる。

## 使用しているライブラリを知る

### スレッドセーフなコレクションを知る

- 動作環境で使用可能なクラスを調査する
    - Javaならば、```java.util.concurrent```, ```java.util.concurrent.atomic```, ```java.util.concurrent.locks```

## 実行モデルを見分ける

- 同時並行処理アプリで振る舞い分割をするためには、いくつかの方法がある。
    - 束縛リソース
        - データベース接続や、固定長の読み書き可能バッファなど。
    - 相互排他
        - 同時に、共有リソースに1スレッドしかアクセスできない
    - 飢餓状態（リソーススタベーション？）
        - あるスレッド、スレッドグループが、実行機会を与えられないこと
            - 高速動作するスレッドが、いつも最初に通り抜けるが、そのスレッドが終了しない場合、プロセスに必要なリソースを獲得できないこと
    - デッドロック
        - 複数のスレッドがお互いの終了を待って、処理が進まない状態
    - ライブロック
        - 複数のスレッドが同時に動作して、処理しようとしたら、お互いが「邪魔しあって」しまう状態。

> デッドロック は複数の参加者が、先に進めるために特定の状態に変化するのをお互いに待っている状況で発生します。 特定の状態に変化する参加者が誰もいないため、誰も先に進むことはできず(行き詰まり状態) 、全てのサブシステムが影響を受けます。 参加者のスレッドが他のスレッドの進行を無限に遅らせることは必然であることから、デッドロックは、 ブロッキング と密接な関係にあります。
>
> デッドロック の場合は参加者の誰も先に進むことができません。対照的に、 スタベーション が起きときは、先に進むことができる参加者がいます。ただし、１人または複数の参加者はできないかもしれません。ネイティブのスケジューリングのアルゴリズムの事例のよくあるシナリオでは、低優先度のタスクよりも高優先度のタスクの方をいつでも選択します。もし、高優先度のタスクの発生数が常に高い状況であるなら、低優先度のタスクは終了しなくなります。
> 
> ライブロック は、参加者が誰も先に進めないという点で デッドロック と似ています。その違いは先に進むために他者を待ったままの状態で凍結するのではなく、参加者同士が絶えず状態を変化し続けてしまうことにあります。2人の参加者には利用可能な２つの同一のリソースがある例を挙げます。彼らはそれぞれリソースを取得しようとしますが、同時に他者がリソースを必要としているかもチェックします。もしリソースが他の参加者に要求されている場合は、別のインスタンスのリソースを取得しようとします。不幸な場合では、2人の参加者の間で2つのリソースが、"行ったり来たり" し続けることが起きるかもしれず、永久にリソースを獲得できず、常に他者に譲り続けることになります。

### プロデューサーコンシューマ

[デザインパターン紹介](https://www.hyuki.com/dp/dpinfo.html#ProducerConsumer)

テーブル = キュー

> 以下のサンプルプログラムはProducer-Consumerパターンの例ですが、 次のような制約があります。
> 
> Producerは3人、Consumerは3人。
> データ（ここでは「食べ物」）を置く場所（テーブル）は1つ。
> テーブルには食べ物を1つしか置けない。
> Producerはテーブルが空いていたら自分の生産した食べ物を置く。 　空いていなかったら空くまで待つ。
> Consumerはテーブルの上に置かれている食べ物をとって食べる。 　食べ物がなかったら置かれるまで待つ。
> 並行性や排他制御に慣れていないと、どこに制約があるのかわかりませんね。 もう少しはっきり書きましょう。> 
> 
> Producerが自分の生産した食べ物をテーブルに置く前に、 テーブルが空いているかどうかを調べるが、 調べてからテーブルに置くまでの間に、他のProducerに先を越されてはいけない （間に割り込めない）。
> Consumerがテーブルの食べ物をとる前に、 テーブルに食べ物があるかどうかを調べるが、 調べてからとるまでの間に、他のConsumerにとられてはいけない。
という制約があります。

### リーダーライター

[EFFECTIVATS: リーダー/ライター問題](http://jats-ug.metasepi.org/doc/ATS2/EXAMPLE/EFFECTIVATS/Readers-and-Writers/main.html)

- 共有リソースが主に読み込みのみに使用され、更新はたまにしか発生しない場合、スループットが問題になる
- 正しい操作、許容範囲のスループット、飢餓状態の回避をみたしつつ、リーダーとライターの要件の妥協点を見つける
    - リーダーを優先した場合、スループットは上がるが、ライターの処理が中断しやすくなる
    - ライターを優先した場合、更新は早くなるが、スループットは遅くなる

### 哲学者の食事

[食事する哲学者の問題 - Wikipedia](https://ja.wikipedia.org/wiki/%E9%A3%9F%E4%BA%8B%E3%81%99%E3%82%8B%E5%93%B2%E5%AD%A6%E8%80%85%E3%81%AE%E5%95%8F%E9%A1%8C)

- 複数の食事リソースを、各スレッドが定められた順番でロックする方法
- 注意深く設計しないと、デッドロック、ライブロック、スループット、効率低下といった問題を引き起こす可能性がある

## 同期化メソッド間の依存関係に注意

- 共有されるオブジェクトのメソッドを2つ以上使用してはいけない
- どうしても共有したい場合
    - クライアントベースロック
        - クライアントがサーバのロックを獲得、最後のメソッド呼び出しまでロックを維持。
    - サーバベースクロック
        - サーバをロックするメソッドをサーバ側が用意。すべてのメソッドを呼んでからロックを解除。
    - サーバ適合
        - ロックを実行する中間層を作成。
        - サーバベースクロックと言えるが、元サーバを変更せずに済む。

## 同期化セッションを小さくする

- 同期化セクションは、できる限り小さくする。
    - クリティカルセクション（プログラムが正しく動作するように、あるセクションのコードが、同時に実行されないようにすること。）を小さくする。

## 正確な終了処理コードを書くのは難しい

- 常駐して永遠に動き続けるシステム ≠ 一定時間稼働し、きれいに終了するものを書く
- 同時並行処理をきれいに終了させるコードを書くのは困難
    - 早い時期に終了処理について検討する
    - 既存のアルゴリズムを見直すことも検討する
        - 思っている以上に難しく、時間がかかるため。

## スレッド化されたコードのテスト

- コードが正しいことを証明することは困難。
- 優れたテストを実行することで、リスク低減につながる
- **潜在的な問題をあぶり出すテストを書き、様々なプログラム構成、システム構成で頻繁に実行する。**
    - テストに失敗した場合は、失敗原因を調査する。
    - 次回の実行でテストが成功したとしても、失敗を無視しない。

### 怪しい失敗を、スレッド問題の容疑者として扱う

- スレッド化されたコードの場合、エラーを再現することが難しい場合がある。
    - システムのエラーを**一過性の問題**と思って片付けないこと。

### 最初にスレッド化されていないコードを完成させる

- マルチスレッド環境以外でも動作するコードをかく
    - POJOを作って、自分のスレッドから呼び出すこと
        - POJOはマルチスレッド前提ではないため、マルチスレッド環境でテストしなくてもよい。
- 非マルチスレッドのバグと、マルチスレッドのバグを同時に追いかけないこと

### スレッド化されたコードを差し替え可能とする

- スレッド環境下で稼働するコードは、さまざまな構成で実行可能とするため、差し替え可能にしておく。
    - 1スレッド、複数スレッドを変更できる環境
    - スレッド化されたコードを、本番にもテスト代役になるものと相互作用させる
    - 高速、低速、可変速で動作するテスト代役で実行する
    - 何度も繰り返し実行できるようにテストを構成する

### スレッド化されたコードをチューニング可能にしておく

- 使用するスレッドの数を簡単に調整できるようにする
    - スループットやシステム利用率を見て、最適なスレッドのバランスを見つけるため

### プロセッサの数よりスレッドの数を多くする

- システムがタスクスイッチするときに問題が起こりやすい。
    - タスクスイッチを促すために、プロセッサのコア数より多いスレッドで実行すること
        - クリティカルセクションの不備やデッドロックという問題が見つかるかも

### 異なるプラットフォームで実行する

- OSそれぞれ異なるスレッドの実装方法をもっているため、可能な限り多くの環境でテストを行うべき。

### コードに対していろいろなことを試し、強制的にエラーを発生させる

- 同時並行処理コードでは、問題が隠れてしまうことが多い。
    - 手作業によるもの、自動的に行うものがある

### 手作業によるもの

- ```Object.wait()``` , ```Obect.sleep()``` , ```Object.yield()``` , ```Object.priority()``` メソッドなど、実行順序を変えるメソッドを使用する
- どこに差し込むか、手作業（人の目）で見つける必要がある
    - どこに差し込むか、何の呼び出しを追加するかをどうやって判断すればよいか？
        - システムをPOJOで構成し、スレッドに関与しないクラス、スレッド処理を制御するクラスに分けると、どこに差し込むか見つけやすい
    - コードが本番環境に残ると、実行速度が低下する
- テスト時だけ行い、本番に入ったらやめる必要あり。

### 自動的に行うもの

- アスペクト指向フレームワーク（CGLIBやASM）を使うと、プログラム的にコードを変更できる
    - コードに異なる順序、異なるタイミングで揺さぶりをかけることが重要
        - エラーを発見できる確率は高くなる

```java:単純なメソッドのクラス
public class ThreadJigglePoint {
  public static void jiggle() {
  }
}
```

```java:呼び出し側
public synchronized String nextUrlOrNull(){
  if(hasNext()) {
    ThreadJiglePoint.jiggle();
    String url = urlGenerator.next();
    ThreadJiglePoint.jiggle();
    updateHasNext();
    ThreadJiglePoint.jiggle();
    return url;
  }
  return null;
}
```

そして、何もしない、スリープする、```yield``` することをランダムに選択する単純なアスペクトを使う。

## 結論

- 単一責務の原則に従う
- ライブラリと基本的なアルゴリズムについて学習する
- ロックが必要なコード領域を探す方法、ロックする方法を学習する

# 第14章　継続的改良

### インクリメンタル主義で

- 大量に変更すると（改善という名の下）、改善前と同じように動作させることが非常に困難。
    - これを避けるために、TDD（テスト駆動開発）を用いた

# 第15章　JUnitの内部

- expected = 予期される、起こる可能性がある
- actual = 実在の、存在している、行われている
- Assert = 断言する、強く主張する
- context = 文脈
- deprecation = 批判、反対
- ```@SuppressWarnings("deprecation")``` = 警告メッセージを抑制する

## ComparisonCompactor

### 各メソッドの役割

- ```compact(String message)``` = 一致している箇所は ```...``` 表記にするメソッド
- ```findCommonPrefix()``` = 接頭から何文字目から異なるか、```fPrefix``` に格納するメソッド
- ```findCommonSuffix()``` = 接尾から何文字目から異なるか、```fSuffix``` に格納するメソッド
- ```compactString(String source)``` = 一致している箇所は ```...``` 表記にするメソッド(引数によって、接頭か接尾か判断する)
- ```areStringsEqual()``` = ```actual``` と ```expected``` が一致しているか返すメソッド

# 第16章　SerialDateのリファクタリング

// TODO

# 第17章　においと経験則

## コメント

### C1:不適切な情報

- システムで保持しておくべき情報をコメントに残してはいけない

### C2:退化コメント

- 古いコメント、不適切なコメント、間違ったコメントは、最新化するか削除する。

### C3:冗長なコメント

- コードで表現されていることはコメントに残さない。

### C4:記述不足のコメント

- コメントを書くときは、単語は慎重に選び、正確な文法で、句読点の付け方を注意する
    - とりとめもなく書かない

### C5:コメントアウトされたコード

- コメントアウトされたコードは見つけたら必ず削除する。

## 環境

### E1:ビルドに複数のステップを要する

- 1つのコマンドで、プロジェクトのビルドができなければならない
    - 特定の環境に依存したスクリプトが必要となるような状況はNG
    - 追加のJARファイルやXMLファイルなどをダウンロードしなければいけない状況も避ける

```
svn get mySystem
cd mySystem
ant all
```

### E2:テストに複数のステップを要する

- コマンド一発ですべての単体テストを実行できるようしておくべき
    - IDEでボタン1つを押せば、すべてのテストが実行されることがベスト

## 関数

### F1:多すぎる引数

- 関数の引数は少なくすべき。
    - 引数がないのがベスト。
    - 3つ以上はNG。

### F2:出力引数

- 出力引数は使用しない。

### F3:フラグ引数

- Boolean引数（フラグ引数）は使用しない。
    - その関数が2つ以上のことを行っていることを宣言していることが分かる

### F4:死んだ関数

- 呼び出されないメソッドは削除する

## 一般(P.375)

### G1:1つのソースファイルに複数の言語を使用する(P.375)

- 理想は、1つの言語のみでソースファイルが構成されること
    - 可能な限り、言語の数と量を最小化すべき

### G2:あって当然の振る舞いが実装されていない(P.375)

- 「驚き最小の原則」に従い、関数とクラスを作成するときは、プログラマが当然と期待する振る舞いを実装する


### G3:境界値に対する不正確な振る舞い(P.376)

- 自分の直感に頼らず、あらゆる境界条件を見つけてテストコードを書く

### G4:安全軽視(P.376)

- 失敗するテストは無視しない。
    - 後で通るように修正しよう！とは絶対に思わないこと。

### G5：重複(P.376)

- あらゆる場所の重複を発見して削除する

### G6:抽象レベルが正しくないコード(P.377)

- 抽象クラスには抽象レベルの高い概念を、継承クラスには抽象レベルの低い概念を持たせるようにして、しっかり抽象レベルの分離をしなければならない。
- 抽象クラスに実装詳細に関わる定数・変数・ユーティリティ関数を置いてはいけない。
- 抽象層の分離は困難で、間違えた場合、簡単に修正することはできない

### G7:継承クラスに依存したベースクラス(P.378)

- 親クラスが子クラスに依存してはいけない
    - 親クラスが子クラスの名前を知っていたら、何らかの問題がある
        - 子クラスの数を固定したい場合などは例外

### G8:情報過多(P.379)

- データ、ユーティリティ関数、定数、一時的な構成物は隠す
- 大量のメソッド、インスタンス変数をもつクラスを作成しない
- 大量のprotected変数、関数を作成しない
- 情報を制限して、結合度を弱める

### G9:デッドコード(P.379)

- デッドコードを見つけたら、すぐに削除

### G10:垂直分離(P.379)

- 変数と関数は、使用される場所の近くで定義する
- ```private``` 関数は使用される場所のすぐ下に定義する

### G11:不整合(P.380)

- 一度その方法を採用したら、すべて採用した方法を使用すること
    - 例1） ```HttpServletResponse``` を保持する変数に ```response``` という名前をつけたら、別の ```HttpServletResponse``` オブジェクトを使用する関数でも同じ変数名を一貫して使用する
    - 例2） ```processVerificationRequest``` というメソッド名にしたら、別のリクエストを処理するメソッドには、 ```processDeletionRequest``` といった同一の名前を使用する

### G12:雑念(P.380)

- いらないものは消す
    - 何も実装していないデフォルトコンストラクタ
    - 未使用変数
    - 呼ばれていない関数
    - なんの情報もないコメント

### G13:人為的な結合(P.380)

- 依存関係がないものを人為的に結合させてはいけない
    - 例）一般用途で使われる ```enum``` を特定のクラス内に含める
- 関数、定数、変数をどこに宣言すべきか、しっかり検討する


### G14:機能の羨望(P.381)

- ```calculateWeeklyPay``` メソッドが、とあるオブジェクト( ```HourlyEmployee``` )からデータを取得して処理している場合、そのオブジェクト( ```HourlyEmployee``` )を定義しているクラスに定義するべき
    - これを「機能の羨望」という。

```java
public class HourPayCalculator {
  public Money calculateWeeklyPay(HourlyEmployee e) {
    int tenthRate = e.getTenthRate().getPennies();
    int tenthsWorked = e.getTenthsWorked();
    ;
    ;
    ;
    ;
    ;
  }
}
```

- 値を何回も取得するような処理が必要な場合がある。
    - ```HourlyEmployeeReport``` メソッドは、```HourlyEmployee``` を羨望している
        - でも ```HourlyEmployee``` クラスにレポート書式をもたせたくない
        - ```HourlyEmployee``` にレポート書式をもたせてしまうと、書式を変更するたびに ```HourlyEmployee``` に影響を及ぼしてしまう

```java
public class HourEmployeeReport {
  private HourlyEmployee employee;
  public HourlyEmployeeReport(HourlyEmployee e) {
    this.employee = e;
  }
  
  String reportHours() {
    return String.format("Name: %s\tHours:%d.%1d\n", 
            employee.getName(), 
            employee.getTenthsWorked()/10, 
            employee.getTenthsWorked()%10);
  }
}
```

### G15:セレクタ引数(P.382)

- 関数の振る舞いを、引数の値で選択するような実装をしてはいけない
    - 別々の関数に分けて、小さな関数に分割する

### G16:不明瞭な意図(P.383)

- コードの読み手に、コードの意図が分かるようにする
    - 意図を不明瞭にする記法はNG
        - 長々と続く式
        - ハンガリアン記法
        - マジックナンバー

### G17:責務を持たせる場所の間違い(P.383)

- 「驚き最小の原則」に従って、読み手が当然と思うべき位置におく。
- 関数の名前に気をつける

### G18:不適切なstatic(P.384)

- 迷ったら非 ```static``` 関数
    - 多態的な振る舞い（ポリモフィズム？？）が必要になるかどうか


### G19:説明的変数(P.385)

- 計算の途中結果を変数に格納し、その変数に説明的な名前をつける
    - やりすぎということはない
    - 説明的な変数を心がける

### G20:関数名は体を表すべき(P.385)

- 関数が何をしている知るために、実装を見なければならないようにする
    - よりよい名前をつける
    - 提供する機能を整理して、もっとよい名前をもった複数の関数に分けるべき

### G21:アルゴリズムを理解する(P.386)

- テストをすべて通ればOKとしない
- OKと判断する前に、最適なアルゴリズムか確認する
- 常にリファクタリングして、何が行われているか分かりやすくする
- コードがどのように動作しているか知ること ≠ アルゴリズムが処理要件を満たしているかを見分けること

### G22:論理的な依存性を物理的なものとする(P.387)

- 「論理的な依存性」と「物理的な依存」

// TODO

### G23:if/elseやswitch/caseよりも多態を好む(P.388)

- 筆者のswitchルール
    - 「ある型の選択において、 switch 文は1つまでにすること。このswitch文は多態的にオブジェクトを生成し、システムの残り部分では、代わりにこれを使用します。」
    - 型の選択の場合に、 switch 文を使用する
    - それ以外は、多態的に判断する

### G24:標準の規約に従う(P.388)

- 業界で一般的なコーディング標準に従う

### G25:マジックナンバーを名前付けした定数に置き換える(P.389)

- マジックナンバーは、意図が明確な名前の定数に置き換える
    - ```FEET_PER_MILE``` , ```WORK_HOURS_PER_TWO``` など、定数をそのまま生の数値にしておいたほうがよい場合もある
 
### G26:正確であれ(P.390)

- コードのあいまいさ、不正確さは取り除く
    - 例外的なケースの場合、どうするか考慮しておく
    - ```null``` を返すかもしれない関数を呼んだら、戻り値の ```null``` チェックを忘れない
    - 結果が1件しか返ってこないDB参照も、複数レコード返ってきていないかチェックする
    - 通貨を扱うなら、整数を使って丸めを正確に行う
    - 同時更新の可能性があるなら、なんらかのロック処理を用意する

### G27:規約より構造(P.390)

- 規約より、構造で強制する
    - イケてる命名の ```enum``` を使った ```switch/case``` ＜ 抽象メソッドを持ったベースクラス

### G28:条件をカプセル化せよ(P.391)

- 条件の意図を説明する関数を抽出すべき

```java
if (timer.hasExpired() && !timer.isRecurrent())
```

より

```java
if (shouldBeDeleted(timer))
```

### G29:条件の否定形を避ける(P.391)

- 否定形の条件はわかりにくいので、可能な限り肯定形で表現する

```java
if (!buffer.shouldNotCompact())
```

より

```java
if (buffer.shouldCompact())
```

### G30:関数では1つのことを行うべき(P.391)

- 1つのことを行う関数に分割すべき

### G31:隠れた時間軸上の結合

- 関数の引数をうまく構成し、呼び出し順序が分かるように構成する
    - 関数の呼び出しに順序があって、間違えると ```Exception``` が発生してしまう場合など

### G32:いいかげんにならないこと

-  なぜそこに書くのか、常に根拠をもってコードを書く
    -  根拠とコードに矛盾がないように注意する

### G33:境界条件をカプセル化する(P.394)

- 境界条件は、1つの場所にまとめておく

```java
    if(level + 1 < tags.length) {
      parts = new Parse(body, tags, level + 1, offset + endTag);
      body = null
    }
```

より

```java
    int nextLevel = level + 1;
    if (nextLevel < tags.length) {
      parts = new Parse(body, tags, nextLevel, offset + endTag);
    }
```

### G34:関数は1つの抽象レベルを担うべき(P.395)

- 1つの関数の中の文章は、常に同じ抽象レベルで書かれるべき
    - 関数の名前で表現された抽象レベルより1つ下

### G35:設定可能なデータは高いレベルに置く(P.396)

- 抽象度の高い定数やデフォルト値は、抽象度の低い関数内に定義されてはいけない。

### G36:推移的なナビゲーションを避ける(P.397)

- １つのモジュールに、協調動作する他のモジュールに関する情報をもたせたくない
    - クラスAがクラスBに依存し、クラスBがクラスCに依存しているとき、クラスAはクラスCを操作しないようにする。
    - ```a.getB().getC().method()``` のようなことはしてはいけない。
        - ```myCollaborator.doSomething()``` にすれば済む

## Java

### J1:ワイルドカードを使って、長いimportのリストを避ける(P.398)

- パッケージのクラスを2つ以上使用する場合、ワイルドカードを使う
    - ```import package.*;```

### J2:定数を継承しない(P.399)

- 定数を含むクラス、インターフェースを継承しない
- ```static import``` を使おう

### J3:定数とenum（P.400)

- ```public static final int``` より ```enum``` を使用する

## 名前

### N1:記述的な名前を選ぶ(P.401)

- 名前は、時間をかけてしっかり検討する
    - 名前を注意することで。コードの構造上に説明を積み上げることができる

### N2:抽象レベルに適切な名前を選ぶ(P.403)

- 実装をそのまま表す名前ではなく、いま作業しているクラス、関数の抽象レベルを反映した名前を選ぶ
- 抽象レベルは改修や機能追加で変化していくので、アップデートしていく

### N3:可能な限り標準の用語を使用する(P.404)

- 既存の規約、一般に利用される用語があれば、それを使用する
- 特定のプロジェクトの名前体系を定義することがある
    - プロジェクトのための**ユビキタス言語**
    - 読み手が何をしようとしているか簡単に理解できる


### N4:はっきりした名前(P.404)

- 関数や変数の働きを的確に表す名前を選択する
- ```doName``` 関数の中で ```renamePage``` 関数の呼び出しが存在していると、違いが分からない
    - 長くても ```renamePageAndOptionallyAllReferences``` としたほうがよいかも

### N5:広いスコープには長い名前を(P.405)

- 名前の長さは、スコープの広さに対応させる
    - 小さいスコープで使用する変数名は、短いもので構わない
    - 大きなスコープで使用する変数名は、長い名前を与える
- ```i``` や ```j``` は、5行までのスコープ
- スコープが広ければ、名前は長く性格でなければならない

### N6:エンコーディングを避ける(P.406)

- 名前の中に、型やスコープ情報を埋め込んではいけない
    - ```m_``` や ```f``` を頭につけるのは無意味
    - プロジェクト名やサブシステム名 ```vis_``` (virtual imaging system)を埋め込むことも無意味

### N7:名前で副作用を示すべき(P.406)

- 関数、変数、クラスが何であり、何をするのかは名前で表現すべき
    - 名前で表現されていない機能（副作用）はNG

## テスト

### T1:不十分なテスト(P.406)

- どこまでテストを作成するか、「それで十分そうなら」という条件にしてはいけない
- テストスイートは、壊れる可能性のある全てに対して行うべき
    - 網羅されていない条件、検証されていない計算処理があるテストは不十分

### T2:カバレッジツールを使用する！(P.406)

- カバレッジツール ＋ IDEで、テストされていないコードを見つけることができる
    - テストでカバーされた行を緑、そうでない行を赤で示してくれる
        - チェックされていないif、catch文の本体を簡単に見つけることができる

### T3:ささいなテストを省略しない(P.407)

- テストがささいなら、書くことも簡単

### T4:無視することを指定されたテストは、あいまいさへの問いかけである(P.407)

- テストをコメントアウトするか、```@Ignore``` をつけてテストを無視するなどして、要件が不明確であいまいであることを示すことができる

### T5:境界条件テスト(P.407)

- 境界条件のテストには注意を払う
    - アルゴリズムが正しくても、境界条件で間違えることがある

### T6:バグの周辺は徹底的にテストを(P.407)

- ある関数でバグを見つけたら、その関数を徹底的にテストする
    - 他のバグが見つかる可能性がある

### T7:失敗パターンは何かを語る

- テストケースの失敗から問題を発見できることがある

### T8:テストカバレッジのパターンは何かを語る

- 成功したテストで、実行された行と実行されなかった行を見ると、失敗したテストの原因のヒントになることがある

### T9:テストは高速に実行できるべき

- 遅いテストは実行されない
    - 実行に時間がかかるとテストスイートから削除される
- 高速なテストコードを書く























