---
title: テスト駆動開発メモ
tags:
  - 学習
private: true
updated_at: '2019-11-26T12:10:38+09:00'
id: f80dbbda25f22b13571c
organization_url_name: null
slide: false
ignorePublish: false
---
# 第17章 他国通貨の全体ふりかえり

## プロセス

1. 小さいテストを追加する
2. すべてのテストを動かし、失敗があることを確認する
3. 変更を行う
4. 再びすべてのテストを動かし、すべて成功することを確認する
5. リファクタリングを行い重複を除去する

## テスト品質

- テストコードは、システム開発し続けるためには有益
    - ただ、以下のテストの代替にはならない
        - パフォーマンステスト
        - 負荷テスト
        - ユーザビリティテスト
- テスト評価手法
    - ステートメントカバレッジ
        - 経路網羅率のこと
        - 「全部の処理を1回は通りやがれ！」になるように設定して行うテスト（命令網羅で行うテスト）における「テストを全部やると、これだけ確認できるはずだよ。それに対して、今はこれだけの確認が終わってるよ」な割合のこと
    - 欠陥挿入
        - 「プロダクトコードの任意の行を変更したら、テストが失敗しなければならない」という考え方

        
# 第25章 テスト駆動開発のパターン

- 「テストする」とはどのような意味か
- いつテストするか
- テスト対象のロジックをどう選ぶか
- テストデータをどう選ぶか

## テスト（名詞）（P.187）

- 「テスト」は「評価する」という意味の動詞
    - テストは名詞でもあり、「合格か不合格か判定する手順」を意味する
        - 「自動的に実行される手順」と「ボタンを適当に押して画面を見てみる」とは、かなり感触が違う
- 「さっきの変更でなにか壊したか？」 → 自動テストを実行 → 「オールグリーンだから大丈夫」
    - ミスをする確率を減らすことができる → ストレスも減らすことができる

## 独立したテスト（P.189）

- 筆者は、過去の経験から2つの教訓を得た
    - テスト速度を可能な限り早くして、自分が頻繁に走らせることができるようにすること
    - 問題の大量発生の原因は、だいたい最初のほうのテストが失敗したから、後続テストが不正な状態で開始され、連鎖的にエラーが生じること
        - **細かい粒度でテストできるようにする**

---

- テスト結果が別のテスト結果に影響されるべきではない
    - テストが1つ失敗したら、問題は1つであってほしい
    - テストが2つ失敗したら、問題は2つであってほしい
- テストが独立していれば、テスト実行順序が依存しなくなる
    - 各テストの前準備が簡単になる

## TODO リスト（P．190）

- 何をテストすべきか、着手する前に必要になりそうなテストをリストに書き出しておく
    - 筆者は、頭の中の内容をすべて紙に書き出した
        - 「すぐやる」「あとで」のリストに加えるか、全くやる必要なしか、素早く判断できるようになった
        - 思いついた新しいテストも、リファクタリングも、リストに書く
            - 新しいテストは、基本的に「すぐやる」リストに加えよう

## テストファースト（P.192）

- テストを書くときは、テスト対象となるコードを書く前
    - 実装を終えたあとだと、後からテストを書くことはない

## アサートファースト（P.193）

- アサートも最初に書こう
- テストを書いているときは、実装のことを考える必要がないが、複数の問題を解決しようとしている
    - 機能はどこに属するべきか
    - 名付けはどうするか
    - 結果の正しさをどう検証するか
    - 正しい結果とはなにか
    - テストを書いたことに寄って、新たなテストはないだろうか

## テストデータ（P.194）

- テストが読みやすく、理解しやすくなるテストデータを使おう
    - データに違いがあるなら、その違いは意味があるものでなければならない
- 同じ値は1つのものを表すために使う
    - 1（第1引数） + 1（第2引数） ではなく、 1 + 2 とする
- 「本物に近いデータ」にする
    - 実際に使われているデータをテストに使用する

## 明示的なデータ（P.195）

- 期待値と結果をテスト自身に含めて、それらの関係が明快に分かるようにしよう
    - 考えられる限りの手がかりを残そう
        - コードにマジックナンバーを書くな問題と競合するかも
        - 定数が既に外に定義されているなら使う、未定義なら値を直接定義する

# 第26章 レッドバーのパターン

## 一歩を示すテスト（P.197）

- わかりきってはいないが、書けば動かせそうな気がするテストを最初に書く
    - プログラムを未知の状態から既知の状態へと育てられる

## はじめのテスト（P.198）

- 「何もしない」テストから始めよう
    - はじめは、そこから学ぶものがありそうで、かつ、すぐに書けそうなテストを選ぶ
    - すでに何回か実装したアプリケーションを再実装しているときは、機能が1つか2つ必要になるテストを書いてみよう

#### 何もしないテストって例えば？

- 出力が入力と完全に一致するケース。
    - ポリゴンの設定が既に正規化されており、削減する余地がない
- 入力が可能な限り小さいもの
    - 単一のポリゴンや空のポリゴンリストでもいい
下のようなイメージ

```java
Reducer reducer = new Reducer(new Polygon());
assertEquals(0, reducer.result().npoints);
```

## 説明的なテスト（P.200）

- 他の人とテストコードの形で知識を共有するようにしよう
    - テストを書くことによって、結合時の問題や不具合報告が少ないこと
    - 設計がシンプルで説明がしやすいこと

## 学習用テスト（P.200）

- サードパーティのソフトウェアの新機能を初めて使うときは、テストを書いてみよう
    - API が期待通りに動作するか、徹ストを書いて確かめてみる
        - 想定通りなら、初回からテストは通るだ
    - 学習用のテストコードが失敗したら、自分たちが書こうとしているコードが動くはずがない

## 脱線は TODO リストへ（P.202）

- 脱線しそうになったら、TODO リストに加えて、元の仕事に集中しよう
    - 新しいアイディアに心惹かれても、本来の仕事に割り込ませないようにする

## 回帰テスト（P.202）

- 不具合が報告されたとき、何をやるべきか
    - 不具合を再現させる最小のテストケースを書き、失敗を見届ける
- 不具合部分を独立してテストして、リファクタリングが必要になる場合もある

## 休憩（P.203）

- 疲れたり、手詰まったら休憩をとろう
    - 席を立った途端に思いつくこともある
- 外部から新しい要素を追加すると、新しいアイディアが思いつく
    - 時間単位：飲み物をおいておけば、生理現象として、定期的に休憩したくなる
    - 日単位：定時後に予定を入れておけば、残業に突入することなく、一晩おいて考えられる
    - 週単位：週末に予定を入れておけば、気がかりで消耗するような悩みを吹き飛ばすきっかけになる
    - 年単位：強制的バケーション制度は完全なリフレッシュ効果を発揮する

## やり直す（P.204）

- 手詰まりすぎて、途方に暮れたら、コードを捨ててやり直す
    - ペアプログラミングをする際には、ペアとなるプログラマの交代は作業やり直しの良いきっかけになる

## 安い机に安い椅子（P.205）

- 他の家具はケチっても、椅子だけはとにかく良いものを使おう
    - 机はともかく、椅子は良いものを使う

# 第27章 テスティングのパターン（P.207）

## 小さいテスト（P.207）

- 大きくなってしまったテストが失敗したときどうするか。
    - 大きいテストから問題箇所を抽出して、小さいテストを書く
        - 小さいテストが通ったら、大きい方のテストに戻る

## Mock Object（擬装オブジェクト）パターン

- 構築処理が重かったり、準備に手間がかかるようなリソースに依存したオブジェクトをテストするときはどうするか。
    - 決められた結果を返す偽物オブジェクトを作成しよう！（スタブかな？？）
- よくあるやつがデータベース
    - 本物のデータベースは極力使わない
        - データベースのように振る舞うが、実はメモリ上にあるだけで十分事足りる

```java:DatabaseTest.java
@Test
public class DatabaseTest {
    Database db = new MockDatabase();
    db.expectQuery("SELECT order_no FROM Order WHERE cust_no = 123");
    db.returnResult(new String[]{"Order 2", "Order 3"});
    ...
}
```

- Mock Object を使いたい場合、重いリソースをグローバル変数に置いておくのは難しくなる
    - グローバル変数は、 Mock Object に代入した後、テストが完了後にまたグローバル変数を元に戻しておかないといけない

## Self Shunt（自己接続）パターン（P.209）

- オブジェクトが他のオブジェクトときちんとやりとりしているかテストしたいときはどうするか。
    - テスト対象オブジェクトが本物だと思って話している相手が、実はテストケース自身となるようなテストを書いてみよう

```py:ResultListenerTest.py
def testNotification(self):
    result = TestResult()
    listener = ResultListener()
    result.addListener(listener)
    WasRun("testMethod").run(result)
    assert(1 == listener.count)
```

リスナーには、通知の回数を数える機能が必要そう

```py:ResultListener.py
class ResultListener:
    def __init__(self):
        self.count = 0
    def StartTest(self):
        self.count = self.count + 1
```

それよりも、テストケース自身に埋め込めばいいのではなかろうか。

```py:ResultListenerTest.py
def testNotification(self):
    self.count = 0 # 追加
    result = TestResult()
    result.addListener(self) # selfを引数に追加
    WasRun("testMethod").run(result)
    assert(1 == self.count)

def startTest(self):
    self.count = self.count + 1
```

- Self Shunt パターンで実装すべき振る舞いは「インタフェースの抽出」を行って抽出しなければいけない場合がある
    - インタフェースを抽出するか、既存クラスをブラックボックスとしてテストするか判断する必要がある

## Log String（記録用文字列）パターン（P.211）

- 正しい順序でメソッド呼び出しが行われていることをテストしたいときはどうすればよいか。
    - 記録用の文字列を作り、メソッド呼び出しのたびに文字列に追記するようにしよう！

```py:TemplateMethodTest.py
def testTemplateMethod(self):
    test = WasRun("testMethod")
    result = TestResult()
    test.run(result)
    assert("setUp testMethod tearDown" == test.log)
```

```py:WasRun.py
def setUp(self):
    self.log = "setUp "
def testMethod(self):
    self.log = self.log + "testMethod "
def tearDown(self):
    self.log = self.log + "tearDown"
```

- 通知の順番を問わないならば、文字列を Set に格納して、 Set の比較で Assesrt すればよい

## Crash Test Dummy（衝突実験ダミー人形）パターン（P.212）

- 普通は到達しない、エラー処理部分のコードをテストするにはどうすればよいか
    - 普通にテストをたたく、ただし、例外を発生させる特別なオブジェクトを使うようにする
- オブジェクト全体を偽装する必要はなく、メソッドだけ上書きしてもよい（ Java の無名内部クラス）

## 失敗させたままのテスト（P.213）

- **独り**でプログラミングしているとき、コーディング時間のうまい終わらせ方はあるか
    - 最後に書いていたテストを失敗する状態にして終えよう
    - 文を途中まで書いている状態で席を立つと、戻ってきたときに書きかけの内容を見て、すぐに思い出すことができる

## きれいなチェックイン（P.214）

- チームでプログラミングしているとき、コーディング時間のうまい終わらせ方はあるか
    - テストをすべて通るようにしよう！
        - コードをチェックインする前に、すべてのテストが通ることをすべて確認しよう！
        - いざチェックインしようとしたときに、結合テストスイートが落ちるかも…
    - 最もシンプルなルールは「手元の作業を捨てて始めからやり直し」

# 第28章 グリーンバーのパターン

## 仮実装を経て本実装へ（P.217）

- 失敗するテストを書いてから、最初に行う実装はどのようなものだろうか
    - ベタ書きの値を返そう
        - テストが通るようになったら、本物の式や変数に置き換えよう

## 三角測量（P.220）

- テストから最も慎重に一般化を引き出すやり方はどのようなものだろうか
    - 2つ以上の例があるときだけ、一般化を行うようにしよう

```cs:テストが1つのとき
        [Test]
        public void TestSum()
        {
            Assert.AreEqual(4, Plus(3, 1));
        }

        private int Plus(int augend, int addend)
        {
            return 4;
        }
```

```cs:テストが2つ以上
        [Test]
        public void TestSum()
        {
            Assert.AreEqual(4, Plus(3, 1));
            Assert.AreEqual(7, Plus(3, 4));
        }
```

```cs:パターンが見えたので実装
        [Test]
        public void TestSum()
        {
            Assert.AreEqual(4, Plus(3, 1));
            Assert.AreEqual(7, Plus(3, 4));
        }

        private int Plus(int augend, int addend)
        {
            return augend + addend;
        }
```

## 明白な実装（P.221）

- シンプルな操作を実装するにはどうすればよいだろうか
    - そのまま実装しよう
        - さっきの Plus メソッドはシンプルなので、さっきの手順は踏まなくてもよい
- 明白な実装をしておいて、テストコードでエラーが出たら…
    - そのときは、ギアを下げてグリーンバーにすることから始めよう

## 一から多まで（P.222）

- オブジェクトのコレクションを扱う操作を実装するときはどうすればよいか
    - 単数のときの操作を実装し、それからコレクションでも動くようにする

```cs:一の例
        [Test]
        public void TestSumArray()
        {
            Assert.AreEqual(5, Sum(5));
        }

        private int Sum(int value)
        {
            return value;
        }
```

これができてから、下に置き換える

```cs:多の例
        [Test]
        public void TestSumArray()
        {
            Assert.AreEqual(5, Sum(new int[] {5}));
            Assert.AreEqual(12, Sum(new int[]{5, 7}));
        }

        private int Sum(int[] values)
        {
            var sum = 0;
            foreach (var v in values)
            {
                sum = sum + v;
            }
            return sum;
        }
```

# 第29章 xUnit のパターン

## アサーション（P.225）

- 判断は真偽値で行いたい
    - 真の場合は、すべてうまくいっている
    - 偽の場合は、何か予期しないことが発生している
- 真偽値の調査は、コンピュータで行う

-  `assertTrue(rectangle.area() != 0)` はNG
    -  null 以外の値を返せば通ってしまう
    -  もっと具体的な数値を使って書く（50とか）
        -  ようするに `assertTrue(rectangle.area() == 50)` と書く
        -  もちろん、等価性の判定である `assertEquals(50, rectangle.area())` でよい
- public なメソッドや変数のみでテストを書くべき

## フィクスチャー（P.227）

**テストを実行、成功させるために必要な状態や前提条件の集合を、フィクスチャ**

- 複数のテストから使われる共通なオブジェクトを作るにはどうしたらよいか
    - テストメソッド内のローカル変数をインスタンス変数に引き上げ、オーバーライドした setUp メソッドの中で初期化を行う

```python:filetest.py
def testMethod(self):
    file = File("foobar").open()
    try:
        # テスト実行
    finally:
        file.close()
```

↓

```python:filetest.py
def setUp(self):
    self.file = File("foobar").open()

def testMethod(self):
    try:
        # テスト実行
    finally:
        file.close()
```

複数の finally 節で発生している重複は、 tearDown メソッドで対応

```python:filetest.py
def setUp(self):
    self.file = File("foobar").open()

def testMethod(self):
    try:
        # テスト実行

def tearDown(self):
    self.file.close()
```

## テストメソッド（P.231）

- テストケースをどこに定義すればよいか
    - 「test」から始まるメソッド名に書こう
- テストメソッドの中は、簡単で読みやすく書かなければならない
    - 長く、複雑になっていたら「よちよち歩きゲーム」を始めよう
        - 最終ゴールに向かう一歩を示す最小のテストメエソッドを書くこと
    - テストメソッドの長さは **3** 行を目指そう
- 筆者は、どんな作業でも「アウトライン」作りから始めることが多いとのこと
    - 書きたいテストの短いアウトラインを書く
    - テスト項目を追加したいときは、アウトラインよりも1段下げて記述する
    - 最下位のアウトラインのすぐ下から、実際のテストコードを書き始める

```TupleSpaceTest.java
/* タプルスペースへの追加 */
/* タプルスペースからの削除 */
/* タプルスペースからの読み取り */
```

テスト項目を追加したいときは↓のイメージ

```TupleSpaceTest.java
/* タプルスペースへの追加 */
/* タプルスペースからの削除 */
/** 存在しないタプルの削除 **/
/** 存在するタプルの削除 **/
/** 複数のタプルの削除 **/
/* タプルスペースからの読み取り */
```

## 例外のテスト（P.233）

- 例外発生を期待するテストはどう書けばよいか
    - 期待される例外をキャッチして握りつぶすように書いて、その例外が発生しなかったときだけテストが失敗するようにする

```cs:正常テスト
        [Test]
        public void TestRate()
        {
            exchange.addRate("USD", "GBP", 2);
            int rate = exchange.findRate("USD", "GBP");
            Assert.Equals(2, rate);
        }
```

```cs:例外テスト
        [Test]
        public void testMissingRate()
        {
            try
            {
                exchage.findRate("USD", "GBP");
                Assert.Fail();
            }
            catch (IllegalArgumentException expected)
            {
            }
        }
```

こうしておけば、予期していない例外が投げられたとき、テストも失敗する

## まとめてテスト

- すべてのテストをまとめて走らせたい
    - すべてのテストスイートをまとめたスイートを作る

```java:AllTests.java
public class AllTests {
    public static void main(String[] args) {
        junit.sqingui.TestRunner.run(AllTests.class);
    }
    public static Test suite() {
        TestSuite result = new TestSuite("TFD tests");
        result.addTestSuite(MoneyTest.class);
        result.addTestSuite(ExchangeTest.class);
        result.addTestSuite(IdentityRateTest.class);
        return result;
    }
}
```

# 第30章 デザインパターン

## Command パターン(P.237)

##### 処理の実行をただのメッセージではなく、オブジェクトで表現する

- 処理の呼び出しが、シンプルなメソッド呼び出しより複雑になってしまったとき
    - 処理のためにオブジェクトを作成し、それを起動するようにしよう
- 処理の実行を表現するオブジェクトを作成し、処理に必要になったパラメータは、そのオブジェクトに渡しておく
    - 実行が必要になったら、一般的なプロトコル、例えば run メソッドで実行する
        - Java の Runnable インターフェースが典型的な例

```java:Runnable.java
interface Runnable {
    public abstract void run();
}
```

## Value Object パターン（P.238）

##### 一度作られたら絶対に値が変わらないオブジェクトを作り、別名参照問題を防ぐ

- 広く共有されるものの、同一インスタンスであることはさほど重要ではないオブジェクトを設計するにはどうしたらよいか
    - オブジェクト作成時に状態を設定したら、その後は決して変えないようにする
    - オブジェクト操作は、必ず新しいオブジェクトを返すようにする

## Null Object パターン（P.240）

##### 特殊な条件をオブジェクトで表現する

- 特殊な状況をオブジェクトで表現するにはどうすればよいか
    - その特殊な状況を表現するオブジェクトを作り、通常のオブジェクトと同じメソッド群を実装しよう

返すべき妥当な SecurityManager がない場合は、代わりとなるオブジェクトを返す

```java:System.java
public static SecurityManager getSecurityManager() {
    return security == null ? new LaxSecurity() : security;
}
```

こうすれば、わざわざ get するたびに、null チェックする必要がない

## Template Method パターン

##### 処理の順序を抽象メソッドの並びで表現し、個別の処理は継承によって表現する

- 処理の順序だけ規定し、拡張は将来に向けて開かれた状態にするにはどうすればよいか
    - 他のメソッドを順番に呼び出すだけのメソッドを書こう
- 典型的な処理順序の例
    - 1. 入力・処理・出力
    - 2. メソッド呼び出し
    - 3. 結果の返却

## Pluggable Object パターン（P.243）

##### 2種類以上の実装を持つオブジェクトを呼び出すことでバリエーションを表現する（P.243）

- バリエーションはどう表現すればよいだろうか
    - 最もシンプルなのは、明示的な条件分岐を使う方法だが、その分だけ Object を作成しよう

## Pluggable Selector パターン（P.244)

##### インスタンスごとに異なるメソッドを動的に呼び出すことで、余計なサブクラスを作らずに済ませる

## Factory Method パターン

##### コンストラクタではなくメソッドを呼び出して、オブジェクトを作成する

- オブジェクト作成に柔軟性をもたせたいときは、どうすればよいか
    - 単にコンストラクタを作るのではなく、メソッドを使ってオブジェクトを作成しよう

## Imposter パターン

##### 既存プロトコルの新たな実装を作成して、バリエーションを生み出す

- 処理に新しいバリエーションを導入するにはどうすればよいか
    - 既存オブジェクトと同じプロトコルを備え、実装は異なる新たなオブジェクトを作ろう

## Composite パターン

##### オブジェクトたちの振る舞いの組み合わせを1つのオブジェクトとして表現する

- オブジェクトたちの振る舞いを組み合わせた振る舞いを持つオブジェクトを実装するにはどうすればよいだろうか
    - 構成要素をまとめた Imposter を作ろう

## Collecting Parameter パターン

##### さまざまなオブジェクトから処理結果を集めるためのオブジェクトを引数に渡していく

- たくさんのオブジェクトたちの処理結果を集めるにはどうすればよいか
    - 処理のパラメータに結果格納用のオブジェクトを渡そう

# 第31章 リファクタリング

## 差異をなくす（P.253）

- よく似ているコードを共通化するためにはどうすればよいか
    - コードの内容をだんだん近づけていって、完全に一致したところでひとつにしよう
- よくある例
    - 2つのループ構造がよく似ている。それらを完全に一致させれば、マージできる
    - 2つの条件分岐の内容がよく似ている。それらを完全に一致させれば、分岐を取り除ける
    - 2つのメソッドがよく似ている。それらを完全に一致させれば、1つ消せる
    - 2つのクラスがよく似ている。それらを完全に一致させれば、1つ消せる

---

- ゴールから考えて、変更の最終ステップを非常に小さくすることから考え始める
    - サブクラスを全て消したい！
        - サブクラスのメソッドを親クラスのメソッドと完全に一致させて消していく
        - サブクラスから1つずつメソッドを減らす → 空になるところまできたら、サブクラスの参照を親クラスの参照に置き換え

## 変更の分離（P.254）

- 複数の部分から構成されるメソッドあるいはオブジェクトを変更するには、どうしたらよいか
    - はじめに、変更すべき部分を分離独立させよう
- 変更を分離するリファクタリングって？
    - メソッドの抽出（P.257）
    - オブジェクトの抽出、メソッドオブジェクト（P.262）

## データ構造の変更（P.255）

- データの持ちからを変えるにはどうすればよいか
    - データを一時的に複製しよう

##### 方法

- 内部構造を書き換えたあと、外部インタフェースを変更するやり方
    - 1. 新構造のためのインスタンス変数を定義する
    - 2. 旧構造でデータが設定されている部分をその変数に置き換える
    - 3. 旧構造のデータを使っている部分をその変数に置き換える
    - 4. 旧構造のコードを消す
    - 5. 外部インタフェースに新構造を反映する

---

- API 側から変更を行いたい場合
    - 1. 新構造のパラメータを追加する
    - 2. 新構造のパラメータを内部で旧構造に変換する
    - 3. 旧構造のパラメータを削除する
    - 4. 旧構造を使っている部分を新構造に置き換えていく
    - 5. 旧構造のコードを削除する

---

「一から多へ（P.222）」の変更を行う場合

```py:before
def testSuite(self):
    suite = TestSuite()
    suite.add(WasRun("testMethod"))
    suite.run(self.result)
    assert("1 run, 0 failed" == self.result.summary())

class TestSuite:
    def add(self, test):
        self.test = test
    def run(self, result):
        self.test.run(result)
```

```py:after
def testSuite(self):
    suite = TestSuite()
    suite.add(WasRun("testMethod"))
    suite.run(self.result)
    assert("1 run, 0 failed" == self.result.summary())

class TestSuite:
    def __init__(self):
        self.tests = []
    def add(self, test):
        self.tests.append(test)
    def run(self, result):
        for test in self.tests:
            test.run(result)
```

## メソッドの抽出（P.257）

- 込みいった長いメソッドを読みやすくするにはどうすればよいだろうか
    - メソッドの一部分を別メソッドに分離し、そのメソッドを読み出すようにしよう

##### 方法

1. メソッドの中から、新しいメソッドとして切り出す意味のある部分を探す。ループの中身や、ループ全体、条件分岐の各分岐などがよくある抽出部分
2. 抽出する範囲の外で、一時変数への代入が行われていないことを確認する
3. 旧メソッドから該当範囲のコードをコピーし、コンパイルする
4. 旧メソッドの一時変数やパラメータの中で新メソッドから使うものを、新メソッドのパラメータに追加する
5. 旧メソッドの中から新メソッドを読み出す

## メソッドのインライン化（P.258）

- ねじれたり散らかったりしてしまった制御フローをシンプルにするにはどうすればよいか
    - メソッド呼び出し部分をメソッドそのもので置き換えよう

#### 方法

1. 対象のメソッドをコピー
2. メソッド呼び出し部分にそのメソッド本文をペーストする
3. 仮引数を実引数に置き換える。例えばもし ```reader.getNext()``` の結果を渡しているなら、副作用を生む式であることに注意して、ローカル変数に代入する


## インタフェースの抽出（P.260）

- Javaで、ある処理の実装をもう１種類作るときにはどうすればよいか
    - インタフェース（ interface ) を作り、共通の処理をくくり出そう

#### 方法

1. インタフェースを宣言する。ときには既存クラスの名前を使いたいこともある。そのようなときは、先にクラスの改名を行う
2. そのインタフェースを既存クラスが実装するようにする
3. 必要なメソッドをインタフェースに加え、クラスのほうでは必要に応じてメソッドの可視性を上げる
4. コードの中で宣言される型を可能な限りクラスからインタフェースに書き換える

## メソッドの移動

- メソッドをふさわしい場所に移動するにはどうすればよいか
    - あるべきところにメソッドを加え、それを呼び出すようにしよう

#### 方法

1. メソッドをコピーする
2. 移動先クラスにペーストし、名前を整え、コンパイルする
3. 移動元のオブジェクトがメソッド内で参照されている場合、移動元オブジェクトをメソッドのパラメータに加える。移動元オブジェクトの変数がメソッド内で参照されている場合も、それをパラメータに追加する。メソッド内でフィールドへの代入が行われている場合には、リファクタリングを諦める
4. 移動元クラスのメソッドの中身を新しいメソッドの呼び出しに置き換える

----

- 「メソッドの移動」リファクタリングの長所3つ
    - 対象コードの意味を深く捉えなくとも、メソッド移動の必要があることは容易に分かる。**1つのオブジェクトに対して、2つ以上のメソッド呼び出しが行われているのは、移動のサイン**
    - 素早く安全に行う手順が存在する
    - 目を見張るような結果になることが多い

## メソッドオブジェクト（P.262）

- 複数のパラメータやローカル変数を必要とする込み入ったメソッドを表現するにはどうすればよいか
    - メソッドをオブジェクトとしてくくり出そう

#### 方法

1. オブジェクトを作り、メソッドと同じパラメータを保持させる
2. ローカル変数は、そのままオブジェクトのインスタンス変数として表現する
3. 単一のメソッド run を定義し、その中身は元のメソッドと同一にする
4. 元のメソッドの中で、オブジェクトをインスタンス化し、 run メソッドを呼び出す

## パラメータの追加（P.263）

- メソッドにパラメータを追加するにはどうすればよいか

#### 方法

1. メソッドのインタフェースが定義されている場合は、インタフェースのほうに先にパラメータを追加する
2. パラメータを追加する
3. コンパイルエラーを活用して、呼び出し側コードを修正する

## メソッドからコンストラクタへのパラメータの移動（P.264）

メソッドからコンストラクタへのパラメータを移動するには、どうすればよいか

#### 方法

1. コンストラクタへパラメータを追加する
2. そのパラメータと同名インスタンス変数を定義する
3. コンストラクタ内でインスタンス変数への代入を行う
4. パラメータ ```parameter``` の参照を1つずつ ```this.parameter``` へ書き換えていく
5. パラメータへの参照がなくなったら、メソッドからパラメータを削除し、呼び出し側からも削除する
6. もう付ける必要がなくなった ```this``` を消していく
7. インスタンス変数をふさわしい名前に変更する

# 第32章 TDDを身につける

## 一歩の大きさはどのくらいか（P.265）

- どちらもできるようになろう
    - ロジックに一行加えたり、少量のリファクタリングを自身を持って行うためのテスト
    - ロジックに数百行加えたり、数時間かかるリファクタリングを自信を持って行うためのテスト
- どちらにせよ「小さいステップ」で

## テストしなくてもよいものはあるか（P.266）

- テストすべき対象（ただし自分が書いたものに限る）
    - 条件分岐
    - ループ
    - 操作
    - ポリモフィズム

## 良いテストを見分けることができるか（P.267）

- 設計に問題を抱えている場合
    - 前準備に要するコードが長い
        - 100行とかあったら分割したほうがいい
    - 前準備コードの重複
        - 共通の前準備コードが見つからない場合は、密結合しているオブジェクトかも
    - テスト実行時間が長い
        - 10分以内
    - 脆いテスト
        - 思わぬタイミングで失敗するテストは、アプリケーションのどこかが意外な形で他の部分に影響している可能性がある

## TDD はどのようにフレームワークを導くのか（P.267）

- パラドックス
    - 「将来のことを考えずにコードを書くことが、将来そのコードの状況に適応する可能性を広げる」
    - 「今日のために書き、明日のために設計しよう」 ＝ 「明日のためにコードを書き、今日のために設計しよう」
- 実際の機能開発例
    - 最初の機能は、実装がシンプルですぐに終わる
    - 2番目の機能は、最初の機能のバリエーション。2つの機能重複部分は1つにまとめられて、差異はメソッドやクラスが分かれる形で現れる
    - 3番目の機能は、前の2つの機能のバリエーション。既にある共通機能はそのまま。独自ロジックの置き場所は明確そのもの、新しいメソッドあるいはクラスだ
- 開放閉鎖原則（Open/Closed Principle：オブジェクトは利用に対して開かれていて、修正に対して閉じられているべき）
    - TDD によって開発されたフレームワークは、発生したバリエーションを正確に表現できる
    - バリエーションの導入が速くなれば、TDD は事前設計と見分けがつかなくなる
        - 予期しないバリエーションが行われても、既存のテストを実行すれば、既存機能を壊していないことがすぐに分かる

## どのくらいのフィードバックが必要か（P.268）

- どのくらいテストを書くべきだろうか
    - どの程度の **平均故障間隔（MTBF：Mean Time Between Failures）** を考えるかによる
        - もしもペースメーカーを開発しているなら、絶対に起こらないと証明できない限り、ありえないような条件や組み合わせのテストでも行う意味がある

## どのようなときにテストを消すべきか（P.270）

- テストの数は多いほうがよいが、2つのテストの間に重複がある場合、2つとの残しておくべきだろうか。
    - 2つの判断基準がある
        - 自信：テストを消すことで不安に感じることがあれば、決して削除してはいけない
        - コミュニケーション：テストの読み手には異なるシナリオと映るのであれば、消さずにそのままにしよう

## プログラミング言語や環境は TDD に影響するか（P.271）

- TDD のサイクルを回しやすいプログラミング言語や環境を使うと、いろいろなことを試すことができる
    - 開発効率を上げて、よりよい解き方を見つけることにつながる
        - 純粋な振り返り（レビューなど）に、より時間を使うことができる

## 巨大なシステムをテスト駆動できるか（P.271）

- 重複を除去して、小さいオブジェクトを作ることで、独立してテストをすることが可能
    - システムの大きさには関係ない

## アプリケーションレベルのテストで開発を駆動できるか（P.272）

- アプリケーションレベルのテスト駆動開発（ATDD：appliction test-driven development)を実現するためには…
    - フィクスチャーの作成が困難
    - 顧客にもテストを書いてもらう必要がでてくる → 顧客の責務が変化する
- 本書で紹介しているのは、自分ひとりでできる技術
    - 周りに伝えながら、一歩ずつ進めれば有効
- ATDD は、テストからフィードバックまでが長くなってしまう
    - レッドからグリーンに変化させるまでの時間が長くなる傾向がある
        - グリーンにするために10日を要した → ずっとレッドバーを見続けたことになる
- 結局、開発者視点のテストも欲しくなる
    - グリーンバーがすぐ出る
    - 内部設計をシンプルにできる

※ フィクスチャー：テストを実行、成功させるために必要な状態や前提条件の集合

## 途中から TDD に乗り換えるにはどうすればよいか（P.273）

- テストのことを考えずに書かれたコードは、そもそもテストが書きにくい
    - ロジックを一部切り出して、結果を確かめるくらいしかできない
- テストを書きやすいようにコードを書き直そう！ → 書き直しても機能を壊していないか確認するためのテストがない！ ＝ デッドロック
    - 金を生まずに時間を消費するだけは、持続性のあるプロセスではない

##### じゃあどうするか

- 変更のスコープを狭くする
    - 変更される予定がないものは、すぐ修正できると思っても、ほっておく
- テストとリファクタリングのデッドロックを解消
    - ペアプログラミングで慎重に作業する
    - システムレベルのテスト

## TDD は誰のためのものか（P.274）

- 「より良いコードを書けば、よりうまくいく」
    - TDD をやっていると、コードに最初から最後まで責任が持てる
    - テストが正確になれば、テストスキルが上がれば、システムの振る舞いに対する確信が深まる

## TDD は初期状況に左右されるか（P.275）

- TDD が微視的な初期状況に左右されるなら、巨視的な結果は予測可能だろうか

## TDD とパターンの関係（P.275）

- 筆者の著書は、模倣したい熟練者と同じ振る舞いを生み出せるような、基本的な規則を求める試みである

## なぜ TDD は機能するのか（P.276）

##### どうしたら結合度が低く、凝集度が高く、欠陥率が低く、メンテナンスコストも低いシステムを作れるか

- 欠陥を減らすこと
    - 欠陥を見つけてから修正するまでの時間が短ければ、コストは小さく、安上がりにできる
        - 簡単に修正できると心理的な負担が減る
    - 新規機能の追加も、これまでに蓄積されたバグと新しい欠陥を見分ける必要がない

## 名前の由来は（P.278）

- 開発
    - ソフトウェア開発における伝統的なフェーズ主義が変わってきた
        - いまは、分析→論理設計→実装→テスト→レビュー→結合→デプロイ
- 駆動
    - テストで開発が駆動するから → テストが先で、開発が後
        - 昔は「テストファーストプログラミング」
- テスト
    - 自動化され、具体化された、明確なテスト
    - ボタンを押せば走り出す
    - TDDはテスト技法ではなく、**分析技法**

## TDD と XP（eXtreme Programming）のプラクティスとの関係

- ペアプログラミング
    - 解こうとしている問題に相手の合意が得られないような状況を避けるため
    - 疲れたら、元気な人に変わる
- いきいきとした仕事
    - XPでも、元気なうちに働き、疲れたら休むと提言
    - イライラして試行錯誤して、進展が見られなかったら止める
- 継続的インテグレーション
    - テストによって、頻繁なインテグレーションを可能にする
- インクリメンタルな設計
    - テストのために必要なコードだけ書き、重複を除去すれば、現在の要件に最も適応し、かつ将来のストーリーに対する備えとなる設計が自動的に得られる
- リファクタリング
    - テストによって、大きなリファクタリングをするときの自信になる
- 継続的デリバリ
    - TDD のテストがシステムのMTBF（平均故障間隔）を改善するのであれば、顧客に迷惑をかけることなく、頻繁に本番環境にリリースすることができる

# 付録C 訳者解説：テスト駆動開発の現在

## TDD から BDD へ

- TDD は、「技術者が、どう作るか」に使うものであるという先入観に逆らえず、TDD の性格な理解と啓蒙には至らないのではないかという問題意識
    - テストやアサーションという語彙を（構造を変えずに）別の言葉に置き換えることで、先入観による誤解を避け、TDD 改め BDD の強みを最大限に引き出すことを狙った
    - BDD（Behavior Driven Development） → 振る舞い（Behavior）

## 内側の語彙を変更：RSpec

| 変更前 | 変更後 |
| :-- | :-- |
| assertion | expectation |
| test | example |
| testcase | example group |
| test class | spec |


























